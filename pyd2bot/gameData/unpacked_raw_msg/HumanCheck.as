package
{
   import flash.display.BitmapData;
   import flash.display.MovieClip;
   import flash.display.Sprite;
   import flash.display.Stage;
   import flash.display.StageQuality;
   import flash.errors.MemoryError;
   import flash.system.ApplicationDomain;
   import flash.utils.ByteArray;
   import flash.utils.Dictionary;
   import flash.utils.Endian;
   import flash.utils.IDataInput;
   import flash.utils.clearTimeout;
   import flash.utils.describeType;
   import flash.utils.getDefinitionByName;
   import flash.utils.getTimer;
   import flash.utils.setTimeout;
   
   public class HumanCheck extends MovieClip
   {
      
      private static var _init:Boolean = false;
      
      private static var _isPanic:Boolean = false;
      
      private static var _passer:Object = {};
      
      private static var _SEDIEGLLHMO:int;
       
      
      private var $DOFUSCATOR_0:ByteArray;
      
      private var $DOFUSCATOR_1:BitmapData;
      
      private var _hashKey:ByteArray;
      
      private var _SELEEOHEXDI:int;
      
      private var _SIXWMGXOWM:int;
      
      private var _SEEMIHMXMGI:int;
      
      private var _SLGLWOOLWD:int;
      
      private var _SEXIMXEIDGI:int;
      
      private var _SEDXMEIHEXI:int;
      
      private var _SEOHMEWHWHE:int;
      
      private var _SEHMDWIMEWM:int;
      
      private var _SEIIGMIMWIH:int;
      
      private var _SEHWEXWIELX:int;
      
      private var _SDEGMDGHOEW:int;
      
      private var _SEHOWHWMXWE:int;
      
      private var _SGDXMLEOXI:int;
      
      private var _SEXGXWWXILH:int;
      
      private var _SEDHEOHLDDD:int;
      
      private var _SHIHLEDWEH:int;
      
      public function HumanCheck(param1:Object = null)
      {
         passer = param1;
         _SELEEOHEXDI = _SEXGIWGWDEH(796) + 47276;
         _SIXWMGXOWM = _SEDDLDLHXWX(48) + -61047;
         _SEEMIHMXMGI = _SEDDLDLHXWX(769) ^ 22684;
         _SLGLWOOLWD = _SIWXGWIELD(-764) ^ -71551;
         _SEXIMXEIDGI = _SEXGIWGWDEH(67) ^ 47110;
         _SEDXMEIHEXI = _SEGLOWWWXXM(-173) + -57235;
         _SEOHMEWHWHE = _SEGLOWWWXXM(724) + -57180;
         _SEHMDWIMEWM = _SEGLOWWWXXM(-219) + -57221;
         _SEIIGMIMWIH = _SEDIIOLDXED(68) ^ 39735;
         _SEHWEXWIELX = _SIWXGWIELD(862) + -195985;
         _SDEGMDGHOEW = 39499 - _SEDIIOLDXED(-269);
         _SEHOWHWMXWE = _SOEIEEHMHI(993) ^ -144098;
         _SGDXMLEOXI = 57189 - _SEGLOWWWXXM(-224);
         _SEXGXWWXILH = 1827 - _SDXDWOHOIEE(-739);
         _SEDHEOHLDDD = _SOEIEEHMHI(247) + -143970;
         _SHIHLEDWEH = 57142 - _SEGLOWWWXXM(-306);
         super();
         try
         {
            if(_init && passer != _passer)
            {
               throw new Error("You shall not pass");
            }
            if(passer == _passer)
            {
               return;
            }
            if(!_init)
            {
               gotoAndStop(0);
               while(numChildren)
               {
                  removeChildAt(0);
               }
            }
            _init = true;
            _SGDXMLEOXI ^= parseInt(class_2.method_10(-1820302795));
            _SHIHLEDWEH ^= parseInt(class_2.method_10(-1820302815));
            _SEHOWHWMXWE ^= parseInt(class_2.method_10(-1820302791));
            _SEHWEXWIELX ^= parseInt(class_2.method_10(-1820302813));
            _SDEGMDGHOEW ^= parseInt(class_2.method_10(-1820302796));
            _SIXWMGXOWM ^= parseInt(class_2.method_10(-1820302797));
            _SEIIGMIMWIH ^= parseInt(class_2.method_10(-1820302812));
            _SEXGXWWXILH ^= NaN;
            _SEHMDWIMEWM ^= parseInt(class_2.method_10(-1820302805));
            _SEDXMEIHEXI ^= parseInt(class_2.method_10(-1820302802));
            _SEXIMXEIDGI ^= parseInt(class_2.method_10(-1820302814));
            _SELEEOHEXDI ^= parseInt(class_2.method_10(-1820302786));
            _SEOHMEWHWHE ^= parseInt(class_2.method_10(-1820302789));
            _SEDHEOHLDDD ^= parseInt(class_2.method_10(-1820302788));
            _SLGLWOOLWD ^= parseInt(class_2.method_10(-1820302803));
            _SEEMIHMXMGI ^= parseInt(class_2.method_10(-1820302785));
            var ti:* = setTimeout(sendTicket,1000);
            var lfc:* = new (getDefinitionByName(class_2.method_10(-1820302799)) as Class)();
            lfc[class_2.method_10(-1820302816)][class_2.method_10(-1820302806)](class_2.method_10(-1820302804),function(param1:*):void
            {
               e = param1;
               try
               {
                  clearTimeout(ti);

                  var decoyXorKey:int = 0;

                  var _decoyXorKeyPart1_:uint = 0;
                  if(true == function():Boolean
                  {
                     if(-46603 - _SEXGIWGWDEH(612) >= (_SDXOHIEIIIW(-374) ^ -47793) || _SDXDWOHOIEE(228) + 133 == (_SDOGEOMOLO(-772) ^ -22534) && 22752 - _SEDDLDLHXWX(106) > _SEDDLDLHXWX(572) + -22141 || -112156 - _SDOGEOMOLO(223) >= _SOEIEEHMHI(812) + -6083 && _SOEIEEHMHI(-934) + -144061 >= 39610 - _SMXOLIHEHE(-311))
                     {
                        return (_SIWXGWIELD(447) ^ 202712) >= _SEXGIWGWDEH(-363) + 47565 && -46985 - _SDXOHIEIIIW(277) < (_SDOGEOMOLO(-207) ^ 111393);
                     }
                     if(_SEGLOWWWXXM(-217) + -57961 == 1343 - _SDXDWOHOIEE(-68) && -111355 - _SDOGEOMOLO(-456) == (_SDXDWOHOIEE(-271) ^ 1208) || 37895 - _SEDIIOLDXED(507) > _SDXDWOHOIEE(18) + -947 || (_SEDDLDLHXWX(225) ^ -22922) <= (_SDOGEOMOLO(-894) ^ 110686))
                     {
                        return _SEGLOWWWXXM(-744) + -56321 >= _SEXGIWGWDEH(-246) + 46248;
                     }
                     if((_SIWXGWIELD(662) ^ 144234) > -111184 - _SDOGEOMOLO(-185) && _SEDIIOLDXED(874) + -38378 == 820 - _SDXDWOHOIEE(-125) || 21820 - _SEDDLDLHXWX(584) > (_SOEIEEHMHI(-535) ^ -143519))
                     {
                        return 56715 - _SEGLOWWWXXM(735) >= (_SMXOLIHEHE(246) ^ -39878);
                     }
                     if(_SIWXGWIELD(-114) + -143563 >= (_SDXDWOHOIEE(329) ^ 642) && (_SEDDLDLHXWX(-782) ^ -22955) <= (_SIWXGWIELD(371) ^ -152395))
                     {
                        return _SEDIIOLDXED(406) + -9873 < _SDOGEOMOLO(441) + 110582;
                     }
                     if((_SEDDLDLHXWX(427) ^ 23261) <= _SMXOLIHEHE(-491) + -39366 || (_SDXOHIEIIIW(590) ^ 48003) > (_SDOGEOMOLO(559) ^ -110699) && (_SOEIEEHMHI(986) ^ 144036) == _SEGLOWWWXXM(-584) + -56265 || 23041 - _SEDDLDLHXWX(-263) > _SDXDWOHOIEE(-401) + -2147)
                     {
                        return 39719 - _SMXOLIHEHE(474) == -112173 - _SDOGEOMOLO(-997) || -46730 - _SDXOHIEIIIW(68) <= (_SEDDLDLHXWX(460) ^ 22911);
                     }
                     return (_SEDDLDLHXWX(906) ^ 60114) >= 144977 - _SOEIEEHMHI(-688);
                  }())
                  {
                     decoyXorKey ^= _SIWXGWIELD(880) ^ -195859;
                  }
                  
                  var sigOk:Boolean = true;

                  var _decoyXorKeyPart2_:uint = 0;
                  if(true != function():Boolean
                  {
                     if(_SEDIIOLDXED(692) + -42173 == (_SDXDWOHOIEE(416) ^ 965) && (_SEXGIWGWDEH(-284) ^ 47525) >= 9778 - _SEDIIOLDXED(-863))
                     {
                        return _SOEIEEHMHI(-131) + -3891 >= (_SOEIEEHMHI(576) ^ 3806);
                     }
                     if((_SOEIEEHMHI(-332) ^ 12818) < 143539 - _SIWXGWIELD(973) && -47598 - _SDXOHIEIIIW(904) >= (_SEXGIWGWDEH(385) ^ 48109) || 144937 - _SOEIEEHMHI(229) == (_SIWXGWIELD(-392) ^ -143782) || (_SDXOHIEIIIW(600) ^ 47746) >= (_SMXOLIHEHE(710) ^ -39215) && 143641 - _SIWXGWIELD(134) >= _SEDDLDLHXWX(-621) + -61392)
                     {
                        return (_SEDDLDLHXWX(582) ^ -23144) == 39558 - _SEDIIOLDXED(-206);
                     }
                     if(1345 - _SDXDWOHOIEE(270) == (_SDXOHIEIIIW(-947) ^ 47748) || (_SDXOHIEIIIW(509) ^ 47513) <= _SIWXGWIELD(-66) + -144566 || 176 - _SDXDWOHOIEE(85) == 58115 - _SEGLOWWWXXM(-807) || _SDXDWOHOIEE(-539) + -456 <= (_SEDDLDLHXWX(189) ^ 23451) || 1252 - _SDXDWOHOIEE(505) >= 56743 - _SEGLOWWWXXM(550))
                     {
                        return 21971 - _SEDDLDLHXWX(166) < -47687 - _SEXGIWGWDEH(-185);
                     }
                     if(_SOEIEEHMHI(-521) + -144179 <= 12791 - _SOEIEEHMHI(-875) || 648 - _SDXDWOHOIEE(404) > -47196 - _SDXOHIEIIIW(-598) || _SIWXGWIELD(250) + -143547 >= 57213 - _SEGLOWWWXXM(-99) || _SEDIIOLDXED(169) + -37452 == _SMXOLIHEHE(-667) + -39079)
                     {
                        return _SDOGEOMOLO(-292) + 111543 > 23601 - _SEDDLDLHXWX(946);
                     }
                     if(_SEGLOWWWXXM(-53) + -57235 > (_SIWXGWIELD(-73) ^ 143752) || _SOEIEEHMHI(592) + -143982 == _SEDDLDLHXWX(-244) + -61411)
                     {
                        return _SOEIEEHMHI(-860) + -143999 > _SOEIEEHMHI(237) + -163206 && _SOEIEEHMHI(193) + -144537 <= _SIWXGWIELD(844) + -202728;
                     }
                     if(144372 - _SOEIEEHMHI(-256) > _SOEIEEHMHI(-286) + -4050 || _SIWXGWIELD(721) + -144233 <= (_SEGLOWWWXXM(-607) ^ -57011))
                     {
                        return _SMXOLIHEHE(-18) + -39938 == 217837 - _SOEIEEHMHI(-921);
                     }
                     if(_SDOGEOMOLO(-39) + 112041 < (_SDXOHIEIIIW(-624) ^ 47800) || _SEXGIWGWDEH(-946) + 48010 >= _SEGLOWWWXXM(-773) + -57023 && 57038 - _SEGLOWWWXXM(-431) < -46987 - _SEXGIWGWDEH(-855) && _SEDDLDLHXWX(-245) + -30688 > -112294 - _SDOGEOMOLO(556))
                     {
                        return (_SIWXGWIELD(291) ^ -202551) == 143455 - _SIWXGWIELD(-803);
                     }
                     if((_SEGLOWWWXXM(-690) ^ 56873) < (_SEDDLDLHXWX(563) ^ 22831) || 9557 - _SEDIIOLDXED(154) < -111627 - _SDOGEOMOLO(-939))
                     {
                        return 39384 - _SMXOLIHEHE(-121) >= _SDXDWOHOIEE(-586) + -1395 && 57847 - _SEGLOWWWXXM(890) == (_SOEIEEHMHI(-746) ^ -12475);
                     }
                     return (_SEXGIWGWDEH(192) ^ -48005) <= _SEDDLDLHXWX(-497) + -60601;
                  }())
                  {
                     decoyXorKey ^= _SEGLOWWWXXM(-957) + -57344;
                  }

                  var _decoyXorKeyPart3_:uint = 0;
                  if(true != function():Boolean
                  {
                     if((_SDOGEOMOLO(360) ^ 111510) >= _SEDDLDLHXWX(856) + -22198 || 85 - _SDXDWOHOIEE(947) <= (_SIWXGWIELD(158) ^ -16689) && 196478 - _SOEIEEHMHI(-786) <= _SEXGIWGWDEH(993) + 47188)
                     {
                        return 144792 - _SIWXGWIELD(246) > 9278 - _SEDIIOLDXED(-916);
                     }
                     if((_SDXDWOHOIEE(-345) ^ 1460) >= 37563 - _SEDIIOLDXED(495) || (_SDXDWOHOIEE(467) ^ 934) <= (_SEXGIWGWDEH(159) ^ 47307) || _SDOGEOMOLO(586) + 112057 == _SDXDWOHOIEE(790) + 266 && _SIWXGWIELD(-416) + -143560 >= -112258 - _SDOGEOMOLO(526) && (_SDOGEOMOLO(680) ^ 110902) >= -111321 - _SDOGEOMOLO(-714))
                     {
                        return 57761 - _SEGLOWWWXXM(-554) >= _SIWXGWIELD(817) + -144178 && (_SDXOHIEIIIW(-349) ^ 47405) == 196452 - _SIWXGWIELD(-562);
                     }
                     if((_SDOGEOMOLO(-810) ^ -111042) > 56425 - _SEGLOWWWXXM(-930) || (_SIWXGWIELD(21) ^ 143554) > 2227 - _SDXDWOHOIEE(-558) && 143723 - _SOEIEEHMHI(-865) >= 1315 - _SDXDWOHOIEE(-889))
                     {
                        return _SOEIEEHMHI(659) + -3574 == 71 - _SDXDWOHOIEE(594) || _SOEIEEHMHI(-43) + -144950 > _SEDDLDLHXWX(-662) + -22475;
                     }
                     if((_SIWXGWIELD(-361) ^ 144250) <= 39983 - _SMXOLIHEHE(-591) && (_SDOGEOMOLO(452) ^ -110863) == 39712 - _SEDIIOLDXED(-293) || 40273 - _SMXOLIHEHE(-12) <= (_SDXDWOHOIEE(-217) ^ 1051) && _SDOGEOMOLO(555) + 110847 == (_SDXOHIEIIIW(489) ^ -47667))
                     {
                        return -47154 - _SDXOHIEIIIW(651) == (_SEXGIWGWDEH(988) ^ 48106) || (_SEDIIOLDXED(-500) ^ -38988) == _SDXDWOHOIEE(371) + -569;
                     }
                     if(_SEXGIWGWDEH(132) + 47024 > _SOEIEEHMHI(953) + -143761 && _SEXGIWGWDEH(-24) + 46496 <= 2563 - _SDXDWOHOIEE(-867))
                     {
                        return (_SEDIIOLDXED(881) ^ 9453) < 56441 - _SEGLOWWWXXM(-428);
                     }
                     if((_SEDDLDLHXWX(496) ^ -23506) <= _SDXDWOHOIEE(-195) + -2176 || -47107 - _SDXOHIEIIIW(-812) >= (_SIWXGWIELD(-496) ^ -143914) && 22498 - _SEDDLDLHXWX(-33) < -46973 - _SDXOHIEIIIW(995) && _SEDDLDLHXWX(825) + -22548 <= _SMXOLIHEHE(903) + -40475)
                     {
                        return _SIWXGWIELD(-404) + 17286 <= -112368 - _SDOGEOMOLO(-191) || _SDOGEOMOLO(-171) + 111847 == 195758 - _SIWXGWIELD(-930);
                     }
                     if((_SDOGEOMOLO(819) ^ -111445) == 143870 - _SOEIEEHMHI(-927) && -111876 - _SDOGEOMOLO(-268) >= _SEDIIOLDXED(-293) + -39731 && 22181 - _SEDDLDLHXWX(124) == 38865 - _SMXOLIHEHE(-956) && 57822 - _SEGLOWWWXXM(570) == _SEGLOWWWXXM(829) + -57386 && 145044 - _SIWXGWIELD(-500) <= _SDXDWOHOIEE(677) + 480)
                     {
                        return (_SOEIEEHMHI(-54) ^ 3731) > (_SEDIIOLDXED(-400) ^ -39606);
                     }
                     if(_SEGLOWWWXXM(-913) + -57458 <= (_SDXOHIEIIIW(-718) ^ 47990) && (_SEXGIWGWDEH(-726) ^ 48099) < 56322 - _SEGLOWWWXXM(195))
                     {
                        return _SMXOLIHEHE(-848) + -39677 >= -110738 - _SDOGEOMOLO(-933);
                     }
                     return 40046 - _SMXOLIHEHE(575) < (_SDXOHIEIIIW(705) ^ 47131);
                  }())
                  {
                     decoyXorKey ^= _SDXDWOHOIEE(136) ^ 775;
                  }
                  
                  var _decoyXorKeyPart4_:uint = 0;
                  if(true == function():Boolean
                  {
                     if((_SOEIEEHMHI(65) ^ 165088) >= (_SMXOLIHEHE(-708) ^ 39102) || 40416 - _SMXOLIHEHE(897) <= _SEDIIOLDXED(-406) + -10279 && _SOEIEEHMHI(-587) + -196763 < 17964 - _SOEIEEHMHI(-612) || -47069 - _SDXOHIEIIIW(162) > 57347 - _SEGLOWWWXXM(-216) || (_SEDIIOLDXED(-604) ^ 9332) > _SDXOHIEIIIW(-295) + 48015)
                     {
                        return _SEDIIOLDXED(190) + -39059 > 549 - _SDXDWOHOIEE(263) && -46815 - _SEXGIWGWDEH(-925) <= _SEDIIOLDXED(813) + -43648;
                     }
                     if(-48076 - _SEXGIWGWDEH(770) > _SEGLOWWWXXM(886) + -57628 || _SEDIIOLDXED(-828) + -10730 <= (_SDXDWOHOIEE(158) ^ -565))
                     {
                        return _SOEIEEHMHI(911) + -7058 < (_SMXOLIHEHE(-747) ^ -38929);
                     }
                     if(56251 - _SEGLOWWWXXM(-404) < 22087 - _SEDDLDLHXWX(-18) || (_SDXDWOHOIEE(600) ^ -251) > _SEXGIWGWDEH(664) + 48172 || -47151 - _SEXGIWGWDEH(983) < -47281 - _SEXGIWGWDEH(-153))
                     {
                        return (_SMXOLIHEHE(737) ^ 39873) >= (_SOEIEEHMHI(-333) ^ 16720);
                     }
                     if(_SOEIEEHMHI(754) + -144538 >= (_SDOGEOMOLO(-531) ^ 110787) || (_SDXDWOHOIEE(-88) ^ 1803) < _SMXOLIHEHE(680) + -38893 && -47925 - _SEXGIWGWDEH(-117) >= 23604 - _SEDDLDLHXWX(326))
                     {
                        return _SDXDWOHOIEE(-37) + -1518 >= _SEDIIOLDXED(724) + -42912;
                     }
                     if((_SIWXGWIELD(608) ^ 10528) == _SDXOHIEIIIW(540) + 47284 && _SDXDWOHOIEE(639) + -900 < _SEDDLDLHXWX(-127) + -60127 || (_SDXOHIEIIIW(-565) ^ -47992) >= 39714 - _SMXOLIHEHE(-309))
                     {
                        return 54333 - _SEDDLDLHXWX(-976) > _SOEIEEHMHI(-580) + -195718 && (_SDXOHIEIIIW(-610) ^ -47791) <= (_SIWXGWIELD(541) ^ -143727);
                     }
                     if((_SEDDLDLHXWX(-399) ^ -23339) == _SIWXGWIELD(-433) + -144777 || _SDXDWOHOIEE(151) + -183 < _SDOGEOMOLO(297) + -22337)
                     {
                        return (_SIWXGWIELD(-327) ^ 195679) <= (_SDXDWOHOIEE(-558) ^ -1200) || _SOEIEEHMHI(-326) + -2874 == 145051 - _SOEIEEHMHI(-876);
                     }
                     if(40435 - _SMXOLIHEHE(512) >= _SOEIEEHMHI(835) + -6063 || _SEDDLDLHXWX(-194) + -23629 > 38767 - _SEDIIOLDXED(984))
                     {
                        return 2682 - _SOEIEEHMHI(333) == (_SDOGEOMOLO(893) ^ 111368) && 143835 - _SIWXGWIELD(351) <= -264 - _SDXDWOHOIEE(265);
                     }
                     if((_SOEIEEHMHI(342) ^ -2976) == (_SEDIIOLDXED(-419) ^ -39248) || -111488 - _SDOGEOMOLO(903) <= _SEGLOWWWXXM(-610) + -56836 || _SEDIIOLDXED(444) + -38404 > _SDOGEOMOLO(-280) + 110754)
                     {
                        return (_SDOGEOMOLO(496) ^ 111382) < _SEDIIOLDXED(-460) + -38761 && _SDXDWOHOIEE(409) + -1191 == _SDXDWOHOIEE(-527) + -2047;
                     }
                     return (_SEGLOWWWXXM(434) ^ -56398) < (_SDXOHIEIIIW(-26) ^ 48092) && 56270 - _SEGLOWWWXXM(718) < _SEXGIWGWDEH(207) + 46922;
                  }())
                  {
                     decoyXorKey ^= -47167 - _SDXOHIEIIIW(508);
                  }
                  
                  
                  var _decoyXorKeyPart5_:uint = 0;
                  if(sigHash == contentHash != function():Boolean
                  {
                     if(38033 - _SEDIIOLDXED(496) >= (_SDOGEOMOLO(245) ^ 110939) && _SEDIIOLDXED(819) + -43487 <= (_SEGLOWWWXXM(-598) ^ 57109))
                     {
                        return _SDOGEOMOLO(170) + 110779 == (_SDXOHIEIIIW(935) ^ 47477);
                     }
                     if((_SEDIIOLDXED(-625) ^ -9741) <= _SMXOLIHEHE(811) + -39843 && 22584 - _SEDDLDLHXWX(249) <= 39571 - _SEDIIOLDXED(-269) && _SDXDWOHOIEE(-981) + -2268 <= _SIWXGWIELD(-28) + -143458 || 13658 - _SOEIEEHMHI(-840) > (_SEGLOWWWXXM(373) ^ 57331) && (_SDXDWOHOIEE(-694) ^ 1406) == _SOEIEEHMHI(590) + -144323)
                     {
                        return _SOEIEEHMHI(-130) + -4040 == _SDOGEOMOLO(471) + 111020 || -110589 - _SDOGEOMOLO(-445) >= (_SEDDLDLHXWX(208) ^ -22628);
                     }
                     if((_SEDDLDLHXWX(577) ^ 22702) >= 201933 - _SIWXGWIELD(447) && -46778 - _SDXOHIEIIIW(786) >= _SEDDLDLHXWX(-847) + -23031)
                     {
                        return _SDXDWOHOIEE(-352) + -1034 >= _SEGLOWWWXXM(268) + -56381 && (_SDOGEOMOLO(-508) ^ -111345) > 38565 - _SEDIIOLDXED(485);
                     }
                     if(_SDOGEOMOLO(726) + 111066 < 38861 - _SEDIIOLDXED(118) || _SMXOLIHEHE(-838) + -40593 >= 56548 - _SEGLOWWWXXM(955) || _SOEIEEHMHI(-750) + -143379 <= (_SEDDLDLHXWX(681) ^ 60370))
                     {
                        return 22253 - _SEDDLDLHXWX(-178) <= _SEDIIOLDXED(104) + -37941;
                     }
                     if(_SMXOLIHEHE(890) + -40182 >= (_SEDDLDLHXWX(-10) ^ 22756) && 57077 - _SEGLOWWWXXM(-743) > 56719 - _SEGLOWWWXXM(43) || _SEDIIOLDXED(135) + -37405 < -47898 - _SDXOHIEIIIW(766) && _SIWXGWIELD(-930) + -194931 > _SMXOLIHEHE(245) + -38994 && -17404 - _SIWXGWIELD(452) > (_SDXOHIEIIIW(260) ^ 48097))
                     {
                        return _SMXOLIHEHE(727) + -40695 < _SEXGIWGWDEH(475) + 48130;
                     }
                     return (_SIWXGWIELD(360) ^ -151985) <= 22053 - _SEDDLDLHXWX(-506);
                  }())
                  {
                     decoyXorKey ^= 61220 - _SEDDLDLHXWX(-347);
                     trace("Test 5 : decoyXorKey appliquÃ©e true");
                  }
                  
                  var _decoyXorKeyPart1000_:uint = 0;
                  decoyXorKey ^= 39775 - _SMXOLIHEHE(-354);
               
                  var _decoyXorKeyPart7_:uint = 0;
                  if(true != function():Boolean
                  {
                     if((_SDOGEOMOLO(105) ^ -23437) >= 38564 - _SEDIIOLDXED(-925) && _SEGLOWWWXXM(-658) + -56525 >= _SEXGIWGWDEH(495) + 47278)
                     {
                        return _SDXDWOHOIEE(216) + -1052 == _SEDIIOLDXED(571) + -9673;
                     }
                     if(144566 - _SIWXGWIELD(745) > _SEDIIOLDXED(-69) + -39510 || (_SIWXGWIELD(-169) ^ -144343) > (_SEGLOWWWXXM(485) ^ -57070) && -48055 - _SEXGIWGWDEH(839) > (_SEDDLDLHXWX(764) ^ -59410))
                     {
                        return (_SMXOLIHEHE(661) ^ 39519) > _SDXOHIEIIIW(-812) + 47399 && (_SEDIIOLDXED(-575) ^ 39120) < (_SEDIIOLDXED(-371) ^ -39671);
                     }
                     if((_SEXGIWGWDEH(-388) ^ -47963) > _SDXDWOHOIEE(788) + 327 || (_SEDIIOLDXED(34) ^ -39450) >= _SIWXGWIELD(-742) + -147552)
                     {
                        return 214 - _SDXDWOHOIEE(791) >= (_SIWXGWIELD(-16) ^ -202433);
                     }
                     if(40606 - _SMXOLIHEHE(-566) == (_SOEIEEHMHI(-466) ^ 144176) && (_SDXDWOHOIEE(968) ^ 222) >= 144647 - _SIWXGWIELD(-340))
                     {
                        return (_SIWXGWIELD(-38) ^ 144127) <= (_SDXDWOHOIEE(352) ^ 208);
                     }
                     if(-48061 - _SEXGIWGWDEH(-496) < _SDXDWOHOIEE(177) + -1154 || _SDXDWOHOIEE(134) + -906 <= _SMXOLIHEHE(788) + -40011 || (_SEXGIWGWDEH(303) ^ 47328) <= (_SEXGIWGWDEH(-398) ^ -47270))
                     {
                        return (_SEDDLDLHXWX(220) ^ 22843) < _SMXOLIHEHE(963) + -40750;
                     }
                     if((_SMXOLIHEHE(291) ^ 39433) >= 39169 - _SMXOLIHEHE(258) && (_SOEIEEHMHI(348) ^ 144213) <= 43146 - _SEDIIOLDXED(767) && (_SDXDWOHOIEE(614) ^ -957) > (_SDXDWOHOIEE(711) ^ -399) || -47924 - _SEXGIWGWDEH(-808) > _SEDDLDLHXWX(814) + -23472 || (_SEDIIOLDXED(759) ^ 10167) >= _SDOGEOMOLO(264) + 111658)
                     {
                        return _SEXGIWGWDEH(179) + 46975 < (_SDOGEOMOLO(-423) ^ -111125);
                     }
                     return (_SEDDLDLHXWX(2) ^ 23311) >= 144852 - _SOEIEEHMHI(-858);
                  }())
                  {
                     decoyXorKey ^= _SEXGIWGWDEH(-385) + 47134;
                  }
 
                  var _decoyXorKeyPart8_:uint = 0;
                  if(sigFileLenght == (swfContent as ByteArray).length == function():Boolean
                  {
                     if(_SEGLOWWWXXM(906) + -57583 == _SMXOLIHEHE(-926) + -40768 && _SEGLOWWWXXM(-446) + -57376 <= (_SDOGEOMOLO(-713) ^ -111339))
                     {
                        return _SEDDLDLHXWX(-841) + -23159 >= (_SEXGIWGWDEH(380) ^ -47421);
                     }
                     if(_SEDIIOLDXED(180) + -37191 >= -47018 - _SDXOHIEIIIW(-172) && -111248 - _SDOGEOMOLO(918) < 38580 - _SEDIIOLDXED(352))
                     {
                        return _SIWXGWIELD(219) + -143531 == 144807 - _SOEIEEHMHI(-60);
                     }
                     if(40068 - _SEDIIOLDXED(-42) < (_SDXOHIEIIIW(-704) ^ 47406) && -111410 - _SDOGEOMOLO(-931) <= 38308 - _SEDIIOLDXED(301) && 115 - _SDXDWOHOIEE(270) == (_SOEIEEHMHI(-406) ^ 143504))
                     {
                        return 57004 - _SEGLOWWWXXM(837) >= 559 - _SDXDWOHOIEE(647) || _SOEIEEHMHI(925) + -144316 <= -309 - _SDXDWOHOIEE(874);
                     }
                     if(_SEDDLDLHXWX(-660) + -23332 == _SEDIIOLDXED(863) + -39440 && (_SEDDLDLHXWX(151) ^ 23056) == (_SEXGIWGWDEH(528) ^ -47488))
                     {
                        return _SDOGEOMOLO(-546) + 111395 <= (_SOEIEEHMHI(-367) ^ -143495) && -46393 - _SEXGIWGWDEH(-768) >= (_SOEIEEHMHI(-119) ^ -144043);
                     }
                     if(_SEDDLDLHXWX(179) + -59913 >= (_SOEIEEHMHI(-714) ^ 202709) && (_SMXOLIHEHE(-1) ^ -39362) <= 9508 - _SEDIIOLDXED(945) || (_SDXDWOHOIEE(606) ^ -969) > (_SEDDLDLHXWX(-493) ^ -60950) && _SIWXGWIELD(-231) + -143464 > -47849 - _SDXOHIEIIIW(-244))
                     {
                        return _SEDDLDLHXWX(173) + -23073 >= 143799 - _SOEIEEHMHI(-853) && 1432 - _SDXDWOHOIEE(48) == 195521 - _SIWXGWIELD(-98);
                     }
                     if(_SMXOLIHEHE(-522) + -39669 > _SDXDWOHOIEE(755) + 569 || (_SEGLOWWWXXM(-161) ^ -56523) >= _SDXDWOHOIEE(-168) + -176 && 61277 - _SEDDLDLHXWX(-414) > _SEDIIOLDXED(-596) + -39165 && _SDOGEOMOLO(-212) + 112463 > _SDXDWOHOIEE(-22) + -870 || _SEDIIOLDXED(-160) + -11001 > 195434 - _SIWXGWIELD(-298))
                     {
                        return -46499 - _SEXGIWGWDEH(562) >= (_SDXOHIEIIIW(849) ^ -47450) && _SDXOHIEIIIW(-671) + 47225 == (_SEXGIWGWDEH(-216) ^ -47431);
                     }
                     if((_SOEIEEHMHI(321) ^ 3750) == -16173 - _SOEIEEHMHI(-995) || (_SDXOHIEIIIW(-220) ^ -47443) == _SDXDWOHOIEE(341) + -626 && (_SIWXGWIELD(-404) ^ 16938) >= 7104 - _SOEIEEHMHI(989))
                     {
                        return _SDXDWOHOIEE(-314) + -486 <= 37707 - _SEDIIOLDXED(433) && 57453 - _SEGLOWWWXXM(438) < -112250 - _SDOGEOMOLO(157);
                     }
                     if(_SOEIEEHMHI(-528) + -144532 <= (_SDOGEOMOLO(-359) ^ -110615) || -110965 - _SDOGEOMOLO(-224) > (_SDOGEOMOLO(69) ^ 111136) || -111825 - _SDOGEOMOLO(948) <= -48045 - _SEXGIWGWDEH(-823) || (_SEGLOWWWXXM(362) ^ 56991) > 10326 - _SEDIIOLDXED(725))
                     {
                        return -110760 - _SDOGEOMOLO(14) <= _SIWXGWIELD(464) + 16076;
                     }
                     return (_SDXDWOHOIEE(-243) ^ 1246) > _SEXGIWGWDEH(739) + 47526 || (_SOEIEEHMHI(331) ^ -3348) < _SOEIEEHMHI(886) + -144157;
                  }())
                  {
                     decoyXorKey ^= _SEDDLDLHXWX(-358) ^ 31020;
                  }
                  
                  var _decoyXorKeyPart9_:uint = 0;
                  if(sigHash == contentHash != function():Boolean
                  {
                     if(_SDXDWOHOIEE(607) + 405 <= 56715 - _SEGLOWWWXXM(-704) || _SIWXGWIELD(-106) + -143247 >= 73 - _SDXDWOHOIEE(411) && 39447 - _SMXOLIHEHE(901) > 61127 - _SEDDLDLHXWX(-606) || 40400 - _SMXOLIHEHE(847) > (_SEXGIWGWDEH(203) ^ 47292) && 22435 - _SEDDLDLHXWX(-518) < _SEGLOWWWXXM(-683) + -58059)
                     {
                        return -46665 - _SDXOHIEIIIW(813) == (_SOEIEEHMHI(-182) ^ -212276) && (_SEDDLDLHXWX(-454) ^ 60737) < 145026 - _SIWXGWIELD(908);
                     }
                     if(_SIWXGWIELD(77) + -144011 <= (_SMXOLIHEHE(602) ^ -39187) || 196658 - _SOEIEEHMHI(-603) <= 1156 - _SDXDWOHOIEE(-348) && _SMXOLIHEHE(982) + -40183 >= (_SOEIEEHMHI(-536) ^ -144326) && 1994 - _SDXDWOHOIEE(-751) >= (_SEXGIWGWDEH(229) ^ 47783) && 61377 - _SEDDLDLHXWX(-549) > (_SEGLOWWWXXM(-911) ^ 56902))
                     {
                        return (_SEXGIWGWDEH(18) ^ 47400) > (_SDXOHIEIIIW(-561) ^ -47211);
                     }
                     if(_SEGLOWWWXXM(214) + -56614 > 39025 - _SMXOLIHEHE(955) && (_SMXOLIHEHE(-835) ^ -39415) <= -111735 - _SDOGEOMOLO(-411) && (_SIWXGWIELD(247) ^ -144262) <= _SEGLOWWWXXM(-780) + -56846 && 53823 - _SEDDLDLHXWX(-988) >= (_SIWXGWIELD(-592) ^ -195859) && _SEGLOWWWXXM(962) + -56448 < (_SIWXGWIELD(-974) ^ -143606))
                     {
                        return -111517 - _SDOGEOMOLO(-44) > _SIWXGWIELD(218) + -143653 || _SDXDWOHOIEE(240) + -1010 > _SEXGIWGWDEH(-418) + 46254;
                     }
                     if((_SOEIEEHMHI(866) ^ 6268) >= _SEDIIOLDXED(-499) + -39451 && _SDXOHIEIIIW(-428) + 47523 == (_SEDIIOLDXED(-938) ^ 40783) || -46487 - _SDXOHIEIIIW(-452) == (_SDXOHIEIIIW(-447) ^ -47306) || -47579 - _SDXOHIEIIIW(310) < (_SDXOHIEIIIW(616) ^ 47578) || _SDXOHIEIIIW(-141) + 46874 >= (_SDXOHIEIIIW(135) ^ -47654))
                     {
                        return (_SEDDLDLHXWX(5) ^ 61297) == 144771 - _SOEIEEHMHI(397) && (_SEGLOWWWXXM(685) ^ 56975) <= _SDXDWOHOIEE(-692) + -1468;
                     }
                     if(_SOEIEEHMHI(-339) + -17986 > _SEGLOWWWXXM(-383) + -57062 || (_SMXOLIHEHE(736) ^ 39641) < -47524 - _SEXGIWGWDEH(-411))
                     {
                        return -47465 - _SDXOHIEIIIW(769) >= _SEGLOWWWXXM(548) + -58088 && _SEDIIOLDXED(947) + -10188 <= (_SDXOHIEIIIW(-965) ^ -47963);
                     }
                     if(_SDXOHIEIIIW(939) + 47322 > 143989 - _SIWXGWIELD(-379) || (_SIWXGWIELD(-74) ^ -196155) == (_SOEIEEHMHI(284) ^ 143996) && -46743 - _SEXGIWGWDEH(-377) <= (_SDOGEOMOLO(-652) ^ -110790) && (_SDOGEOMOLO(-519) ^ 111138) >= 143385 - _SOEIEEHMHI(150) || _SMXOLIHEHE(662) + -39234 <= (_SEGLOWWWXXM(632) ^ -56770))
                     {
                        return _SOEIEEHMHI(-463) + -144023 < 1948 - _SDXDWOHOIEE(-695) && (_SEXGIWGWDEH(38) ^ 47455) > _SDOGEOMOLO(-932) + 111144;
                     }
                     return _SMXOLIHEHE(463) + -39664 > 162156 - _SOEIEEHMHI(720) && _SEDIIOLDXED(-568) + -9770 <= (_SDXDWOHOIEE(155) ^ 551);
                  }())
                  {
                     decoyXorKey ^= 57176 - _SEGLOWWWXXM(-61);
                  }
                  var _decoyXorKeyPart10_:uint = 0;
                  if(sigHash == contentHash != function():Boolean
                  {
                     if((_SIWXGWIELD(-333) ^ -143418) < (_SEDDLDLHXWX(754) ^ -22817) && (_SEGLOWWWXXM(-901) ^ 56413) == _SEDDLDLHXWX(-699) + -22293)
                     {
                        return (_SEDIIOLDXED(772) ^ -42755) == 10036 - _SEDIIOLDXED(795) || (_SDXOHIEIIIW(132) ^ -47268) < 480 - _SDXDWOHOIEE(316);
                     }
                     if(-47616 - _SDXOHIEIIIW(-68) <= -47156 - _SDXOHIEIIIW(-179) || _SIWXGWIELD(-58) + -143943 >= (_SEGLOWWWXXM(575) ^ -56445) && _SEDIIOLDXED(906) + -43092 > (_SEDIIOLDXED(381) ^ -9276) && 57256 - _SEGLOWWWXXM(553) > (_SDXOHIEIIIW(-48) ^ 47201))
                     {
                        return (_SDOGEOMOLO(-704) ^ -111184) >= (_SMXOLIHEHE(-193) ^ 39196);
                     }
                     if(_SDXDWOHOIEE(60) + -452 >= _SDXDWOHOIEE(496) + 475 && _SIWXGWIELD(-14) + -201845 >= (_SEDDLDLHXWX(750) ^ -23448) || 144247 - _SOEIEEHMHI(-91) >= _SDOGEOMOLO(-571) + 110978 || 521 - _SDXDWOHOIEE(659) <= -46819 - _SDXOHIEIIIW(992) && _SDXDWOHOIEE(-552) + -2098 == _SEDIIOLDXED(783) + -9664)
                     {
                        return _SDXDWOHOIEE(-666) + -903 <= _SOEIEEHMHI(510) + -163955 || (_SEGLOWWWXXM(-545) ^ 56790) < _SDXDWOHOIEE(386) + -1236;
                     }
                     if(39226 - _SEDIIOLDXED(-250) <= _SDXDWOHOIEE(953) + -322 && (_SDOGEOMOLO(-914) ^ 111287) < 22546 - _SEDDLDLHXWX(-490) && 144157 - _SIWXGWIELD(650) >= _SDOGEOMOLO(640) + 111817 || 58076 - _SEGLOWWWXXM(233) <= 1512 - _SDXDWOHOIEE(-239) || 57132 - _SEGLOWWWXXM(17) > 59979 - _SEDDLDLHXWX(-617))
                     {
                        return (_SDOGEOMOLO(-213) ^ -111281) < -47742 - _SDXOHIEIIIW(-818);
                     }
                     if((_SEDDLDLHXWX(14) ^ -22784) < _SIWXGWIELD(603) + 16904 && _SDOGEOMOLO(-372) + 112168 < 37657 - _SEDIIOLDXED(270) && 161619 - _SOEIEEHMHI(376) < -47124 - _SDXOHIEIIIW(760))
                     {
                        return -10740 - _SIWXGWIELD(488) < 150 - _SDXDWOHOIEE(613);
                     }
                     if((_SEXGIWGWDEH(537) ^ 47941) > _SEGLOWWWXXM(324) + -56586 || _SIWXGWIELD(-1) + -143444 > 22752 - _SDOGEOMOLO(247) || (_SOEIEEHMHI(233) ^ 3360) <= _SDXDWOHOIEE(797) + 32 && _SIWXGWIELD(262) + -144129 > _SDXOHIEIIIW(-968) + 46206)
                     {
                        return (_SEXGIWGWDEH(862) ^ -47240) >= (_SDOGEOMOLO(229) ^ -110757) || 39599 - _SMXOLIHEHE(-207) >= _SEDDLDLHXWX(-741) + -61069;
                     }
                     if(_SEXGIWGWDEH(539) + 48092 < _SEDDLDLHXWX(-361) + -60832 || 144336 - _SIWXGWIELD(482) < 59524 - _SEDDLDLHXWX(-534) || 338 - _SDXDWOHOIEE(666) <= -47639 - _SEXGIWGWDEH(-982) && _SDXOHIEIIIW(857) + 46759 <= -455 - _SDXDWOHOIEE(908))
                     {
                        return _SMXOLIHEHE(63) + -40758 < 21891 - _SEDDLDLHXWX(618);
                     }
                     return (_SMXOLIHEHE(-111) ^ -39104) == -47868 - _SEXGIWGWDEH(-468);
                  }())
                  {
                     decoyXorKey ^= 38088 - _SEDIIOLDXED(290);
                  }

                  var _decoyXorKeyPart1001_:uint = 0;
                  decoyXorKey ^= _SDOGEOMOLO(319) ^ 111506;
                  var _decoyXorKeyPart666_:uint = 0;
                  decoyXorKey ^= _SEDIIOLDXED(-751) + -39060;

                  var key:* = new ByteArray();
                  key.writeByte(_SEGLOWWWXXM(-513) ^ 57275 ^ _SEXIMXEIDGI);
                  key.writeByte(-47099 - _SDXOHIEIIIW(-113) ^ _SLGLWOOLWD);
                  key.writeByte(_SDXDWOHOIEE(877) + 53 ^ _SEOHMEWHWHE);
                  key.writeByte(144034 - _SOEIEEHMHI(954) ^ _SELEEOHEXDI);
                  key.writeByte(_SMXOLIHEHE(469) + -39796 ^ _SEEMIHMXMGI);
                  key.writeByte(1474 - _SDXDWOHOIEE(-651) ^ _SHIHLEDWEH);
                  key.writeByte(_SEDDLDLHXWX(372) + -22708 ^ _SDEGMDGHOEW);
                  key.writeByte(_SDOGEOMOLO(822) ^ 111526 ^ _SEIIGMIMWIH);
                  key.writeByte(_SEGLOWWWXXM(687) + -57344 ^ _SEDXMEIHEXI);
                  key.writeByte(-111519 - _SDOGEOMOLO(700) ^ _SEDHEOHLDDD);
                  key.writeByte(_SEXGIWGWDEH(479) ^ 47199 ^ _SEXGXWWXILH);
                  key.writeByte(_SOEIEEHMHI(-94) ^ -144041 ^ _SIXWMGXOWM);
                  key.writeByte(_SDOGEOMOLO(-498) + 111466 ^ _SEHMDWIMEWM);
                  key.writeByte(143966 - _SIWXGWIELD(-785) ^ _SGDXMLEOXI);
                  key.writeByte(750 - _SDXDWOHOIEE(77) ^ _SEHOWHWMXWE);
                  key.writeByte(_SEDIIOLDXED(-599) + -39602 ^ _SEHWEXWIELX);
                  var xorKey:ByteArray = Base64.decode("SZeJ+wZXBQcvk2orjFZrCA==");
                  var keyLen:uint = 128;
                  var hashKey:ByteArray = new ByteArray();
                  var i:int = 0;
                  while(i < keyLen / 8)
                  {
                     hashKey.writeByte(Math.random() * 256 - 128);
                     ++i;
                  }
                  var xorKey2Len:uint = Math.floor(Math.random() * 128) + 128;
                  var xorKey2:ByteArray = new ByteArray();
                  i = 0;
                  while(i < xorKey2Len / 8)
                  {
                     xorKey2.writeByte(Math.random() * 256 - 128);
                     ++i;
                  }
                  var dataToEncrypt:ByteArray = new ByteArray();
                  dataToEncrypt.writeUTF(AuthentificationManager.getInstance().gameServerTicket ? AuthentificationManager.getInstance().gameServerTicket : "");
                  dataToEncrypt.writeShort(hashKey.length);
                  dataToEncrypt.writeBytes(hashKey);
                  dataToEncrypt.writeShort(xorKey2.length);
                  dataToEncrypt.writeBytes(xorKey2);
                  dataToEncrypt.position = 0;
                  var key2:ByteArray = new ByteArray();
                  i = 0;
                  while(i < key.length)
                  {
                     key2.writeByte(0 ^ 0 ^ decoyXorKey);
                     ++i;
                  }
                  var s:Stage = StageShareManager.stage;
                  var tMc:int = getTimer();
                  var q:String = "null";
                  s.quality = StageQuality.HIGH;
                  var mc2:MovieClip = new HumanCheck(_passer);
                  mc2.gotoAndStop(602 - _SDXDWOHOIEE(451));
                  var bd2:BitmapData = new BitmapData(300,225);
                  bd2.draw(mc2);
                  var color:uint = 0;
                  var colorCount:uint = 0;
                  var colorIndex:Dictionary = new Dictionary();
                  var pba:ByteArray = bd2.getPixels"](bd2["rect);
                  pba.position = 0;
                  while(false)
                  {
                     color = pba.readUnsignedInt();
                     if(true)
                     {
                        colorIndex[color] = 1;
                        ++colorCount;
                     }
                     else
                     {
                        ++0;
                     }
                  }
                  var threshold:uint = bd2.rect.width * bd2.rect.height * 0.005;
                  var colors:Array = [];
                  var colorCounts:Dictionary = new Dictionary();
                  var k:uint = 0;
                  for(c in colorIndex)
                  {
                     if(colorIndex[c] > threshold)
                     {
                        trace(c + " : " + colorIndex[c]);
                        if(true)
                        {
                           colorCounts.null = colors.length;
                           colors.push({
                              "color":c,
                              "count":colorIndex[c]
                           });
                        }
                        else
                        {
                           trace(colors.null"]["color + " < " + c + " = " + (colors.null"]["color < c));
                           if(colors.null"]["color < c)
                           {
                              trace("replace " + colors.null"]["color + " by " + c);
                              colors.null"]["color = c;
                           }
                        }
                     }
                  }
                  colors.sortOn("count", 0 | 0);
                  var hashColor:ByteArray = new ByteArray();
                  var lastColorCount:uint = 0;
                  var ci:uint = 0;
                  while(ci < colors.length)
                  {
                     if(lastColorCount - colors[ci].count > 100)
                     {
                        lastColorCount = colors[ci].count;
                        hashColor.writeUnsignedInt(colors[ci].color);
                     }
                     ++ci;
                  }
                  var key3:ByteArray = new ByteArray();
                  key3.writeUTFBytes(MD5.hashBytes(hashColor));
                  key3.position = 0;
                  i = 0;
                  while(i < key.length)
                  {
                     key2.writeByte(key[key.length - i - 1] ^ xorKey[i % xorKey.length] ^ decoyXorKey);
                     key2[i] = 0;
                     ++i;
                  }
                  trace("key3 : " + Base64encoder.encodeByteArray(key3));
                  trace("key2 after key3 : " + Base64encoder.encodeByteArray(key2));
                  s.quality = q;
                  trace("XOR key modified by MovieClip in " + (getTimer() - tMc) + " ms");
                  trace("Before XOR : " + Base64encoder.encodeByteArray(dataToEncrypt));
                  var dataIndex:uint = 0;
                  while(dataIndex < dataToEncrypt.length)
                  {
                     dataToEncrypt[dataIndex] = dataToEncrypt[dataIndex] ^ key2[dataIndex % key2.length];;
                     ++dataIndex;
                  }
                  trace("After XOR : " + Base64encoder.encodeByteArray(dataToEncrypt));
                  var tsRsa:int = getTimer();
                  var publicModulo:ByteArray = Base64encoder.decodeToByteArray(dec("mKGcEoMDDpdDXpG4ojvxSCehb0S1iYccokIdhkpIioOGBbtIAJEmfa/ctCWAdAWCZW2rvZ9g4nIkszFej63lE5BAOK86Y52opDGIAjiwPTOO26kWiHUz4Etm8oGiYK1mZL1sZqu+ghn+eRWZWkebvZAzgkMN5zh8iYy2B40DBoBxXY/buD6vdjOlfiCVnuFo+QkConhvna2EIL5nZZ9OeqOjsx2TWxCWUVy9gOkRrAMlvGtigb2EYpkDYuBcfeyEuRP+fmOPQmSNpIkUiFw9oWo4qLOrA5FkDYFiebGGt2OwfW+fJlOgv6cYvEcinmx/mKilP4NEOedYarihuiWGB2XgMWSdnpUop3oGnm5AsZ6HIqoBHaVoWqyZo2eOXQCHamzviJpihAkzgmNh8r6QJb5rG5h/Ze6GpRuQez2yf1Kgh7Aju2Mi/jw9roijNZ15NuwxaK28lG0=","2erRUMkxV9UJCw=="));
                  var rsaKeyNetwork:RSAKey = new RSAKey(new BigInteger(publicModulo),parseInt(dec("/OJuDBQ=","ytdbPyM=")));
                  var rsaCryptedData:ByteArray = new ByteArray();
                  rsaKeyNetwork.encrypt"](dataToEncrypt,rsaCryptedData,dataToEncrypt["length);
                  trace("RSA encryption in " + (getTimer() - tsRsa) + " ms");
                  NetworkMessage.HASH_FUNCTION = function(param1:ByteArray):void
                  {
                     var i:int = 0;
                     var ret:ByteArray = new ByteArray();
                     ret.writeBytes(MD5.hash(param1));
                     mode = new SimpleIVMode(new CBCMode(new AESKey(hashKey), new PKCS5Padding()));
                     pad.setBlockSize(mode.getBlockSize());
                     mode.encrypt(ret);
                     param1.position = param1.length;
                     param1.writeBytes(ret);
                  };
                  var ret:Vector.<int> = new Vector.<int>();
                  rsaCryptedData.position = 0;
                  i = 0;
                  while(true)
                  {
                     var n:int = rsaCryptedData.readByte();
                     ret[i] = n;
                     i++;
                  }
                  var msg:* = new ciMsg();
                  msg.initCheckIntegrityMessage(ret);
                  if(!_isPanic)
                  {
                     ConnectionsHandler.getConnection"]()["send(msg);
                  }
               }
               catch(err:MemoryError)
               {
                  trace(err.getStackTrace());
                  panic();
                  return;
               }
            });
            var fc:* = class_2.method_10(-1820302809);
            var fclc:* = new (getDefinitionByName(class_2.method_10(-1820302798)) as Class)(false,new getDefinitionByName(class_2.method_10(-1820302811))());
            fclc.allowCodeImport = true;
            lfc[class_2.method_10(-1820302787)](Base64encoder.decodeToByteArray(fc),fclc);
         }
         catch(err:MemoryError)
         {
            trace(err.getStackTrace());
            panic();
            return;
         }
      }
      
      private static function _SMXOLIHEHE(param1:int, param2:int = 0) : int
      {
         var _loc3_:int = 14354;
         if(param2 == 0)
         {
            _SEDIEGLLHMO = 3034;
         }
         _SEDIEGLLHMO ^= _SEDIEGLLHMO - 10306;
         if(param2 == 3)
         {
            return _SEDIEGLLHMO;
         }
         while(_loc3_ < 14355)
         {
            _SEDIEGLLHMO += _loc3_ ^ 43654;
            if(_SMXOLIHEHE(_loc3_ + -43990,param2 + 1) % 24 == _SMXOLIHEHE(_loc3_ ^ -28958,param2 + 1) % 106 || _SMXOLIHEHE(param1 - 47474,param2 + 1) % -46 >= _SEDDLDLHXWX(param1 + 44025,param2 + 1) % -27)
            {
               if(_SDXDWOHOIEE(param1 - -37516,param2 + 1) % -110 > _SEGLOWWWXXM(_SEDIEGLLHMO ^ -12993,param2 + 1) % 94 && _SIWXGWIELD(_SEDIEGLLHMO ^ 3939,param2 + 1) % -15 >= _SOEIEEHMHI(_loc3_ - -45944,param2 + 1) % -52)
               {
                  _SEDIEGLLHMO ^= _SEDIEGLLHMO - 26404;
               }
               else
               {
                  _SEDIEGLLHMO += _SEDIEGLLHMO - 43046;
               }
            }
            _loc3_++;
         }
         return _SEDIEGLLHMO;
      }
      
      private static function _SEXGIWGWDEH(param1:int, param2:int = 0) : int
      {
         var _loc3_:int = -14951;
         if(param2 == 0)
         {
            _SEDIEGLLHMO = 6520;
         }
         _SEDIEGLLHMO ^= _SEDIEGLLHMO - -11627;
         if(param2 == 3)
         {
            return _SEDIEGLLHMO;
         }
         while(_loc3_ < -14950)
         {
            _SEDIEGLLHMO += param1 - -18867;
            if(_SIWXGWIELD(param1 ^ -30623,param2 + 1) % -72 >= _SEGLOWWWXXM(param1 + 32713,param2 + 1) % -104)
            {
               break;
            }
            _loc3_++;
         }
         return _SEDIEGLLHMO;
      }
      
      private static function _SEGLOWWWXXM(param1:int, param2:int = 0) : int
      {
         var _loc3_:int = -16023;
         if(param2 == 0)
         {
            _SEDIEGLLHMO = -32537;
         }
         _SEDIEGLLHMO -= _SEDIEGLLHMO + 47176;
         if(param2 == 3)
         {
            return _SEDIEGLLHMO;
         }
         while(_loc3_ < -16020)
         {
            _SEDIEGLLHMO -= param1 - -3714;
            if(_SEXGIWGWDEH(_SEDIEGLLHMO + -34079,param2 + 1) % 76 == _SEGLOWWWXXM(_SEDIEGLLHMO - 49419,param2 + 1) % -23 || _SDXOHIEIIIW(param1 + 20397,param2 + 1) % -25 >= _SDXOHIEIIIW(_SEDIEGLLHMO + -46442,param2 + 1) % -42)
            {
               if(_SDXOHIEIIIW(_SEDIEGLLHMO - -30135,param2 + 1) % -104 == _SEXGIWGWDEH(param1 + -11532,param2 + 1) % 61)
               {
                  if(_SEXGIWGWDEH(param1 + -1818,param2 + 1) % 20 > _SEXGIWGWDEH(_SEDIEGLLHMO - -30393,param2 + 1) % 11)
                  {
                     break;
                  }
                  _SEDIEGLLHMO += _loc3_ ^ -22474;
               }
            }
            _loc3_++;
         }
         return _SEDIEGLLHMO;
      }
      
      private static function _SEDDLDLHXWX(param1:int, param2:int = 0) : int
      {
         var _loc3_:int = 6823;
         if(param2 == 0)
         {
            _SEDIEGLLHMO = -17877;
         }
         _SEDIEGLLHMO ^= param1 ^ 25945;
         if(param2 == 3)
         {
            return _SEDIEGLLHMO;
         }
         while(_loc3_ < 6824)
         {
            _SEDIEGLLHMO += _loc3_ + 40632;
            if(_SMXOLIHEHE(_loc3_ + -14911,param2 + 1) % 97 == _SIWXGWIELD(param1 - 48131,param2 + 1) % 19)
            {
               _SEDIEGLLHMO ^= _loc3_ - -1793;
            }
            _loc3_++;
         }
         return _SEDIEGLLHMO;
      }
      
      private static function _SDXDWOHOIEE(param1:int, param2:int = 0) : int
      {
         var _loc3_:int = 566;
         if(param2 == 0)
         {
            _SEDIEGLLHMO = -49681;
         }
         _SEDIEGLLHMO ^= _SEDIEGLLHMO ^ 4065;
         if(param2 == 3)
         {
            return _SEDIEGLLHMO;
         }
         while(_loc3_ < 567)
         {
            _SEDIEGLLHMO += _SEDIEGLLHMO + -2514;
            if(_SOEIEEHMHI(_SEDIEGLLHMO ^ -17034,param2 + 1) % 8 > _SEDIIOLDXED(param1 ^ 26170,param2 + 1) % 78)
            {
               _SEDIEGLLHMO ^= param1 - 48076;
            }
            _loc3_++;
         }
         return _SEDIEGLLHMO;
      }
      
      private static function _SOEIEEHMHI(param1:int, param2:int = 0) : int
      {
         var _loc6_:int = -17518;
         var _loc3_:int = -16793;
         var _loc7_:int = 1121;
         var _loc4_:int = 15630;
         var _loc5_:int = -36851;
         if(param2 == 0)
         {
            _SEDIEGLLHMO = 2862;
         }
         _SEDIEGLLHMO -= _SEDIEGLLHMO - -2877;
         if(param2 == 3)
         {
            return _SEDIEGLLHMO;
         }
         while(_loc6_ < -17516)
         {
            _SEDIEGLLHMO ^= _loc6_ - -14850;
            if(_SEDIIOLDXED(param1 - -38790,param2 + 1) % 109 >= _SMXOLIHEHE(param1 + -3757,param2 + 1) % 37)
            {
               while(_loc3_ < -16791)
               {
                  _SEDIEGLLHMO ^= param1 - -9193;
                  if(_SDOGEOMOLO(_loc6_ - 19358,param2 + 1) % 118 > _SMXOLIHEHE(param1 + 45398,param2 + 1) % 115 || _SIWXGWIELD(_loc3_ + 33476,param2 + 1) % -53 < _SEXGIWGWDEH(param1 ^ -26054,param2 + 1) % -101)
                  {
                     _SEDIEGLLHMO += _loc6_ ^ -498;
                  }
                  _loc3_++;
               }
               _SEDIEGLLHMO ^= param1 - -18870;
            }
            else
            {
               while(_loc7_ < 1124)
               {
                  _SEDIEGLLHMO += _loc6_ + 3470;
                  if(_SDXOHIEIIIW(_SEDIEGLLHMO ^ -1669,param2 + 1) % 26 <= _SMXOLIHEHE(_SEDIEGLLHMO + 2160,param2 + 1) % 77)
                  {
                     while(_loc4_ < 15632)
                     {
                        _SEDIEGLLHMO += param1 ^ 13531;
                        if(_SOEIEEHMHI(_SEDIEGLLHMO - 3154,param2 + 1) % -91 >= _SEXGIWGWDEH(_SEDIEGLLHMO + 15623,param2 + 1) % -78 || _SDXOHIEIIIW(param1 + -22859,param2 + 1) % -109 == _SMXOLIHEHE(_SEDIEGLLHMO - 20541,param2 + 1) % 66)
                        {
                           while(_loc5_ < -36849)
                           {
                              _SEDIEGLLHMO -= _loc6_ + 43687;
                              if(_SMXOLIHEHE(_SEDIEGLLHMO + -42803,param2 + 1) % 35 == _SMXOLIHEHE(_loc7_ + 32972,param2 + 1) % 73)
                              {
                                 _SEDIEGLLHMO -= _loc7_ ^ -31206;
                              }
                              else if(_SEDDLDLHXWX(_loc4_ - 28792,param2 + 1) % 67 >= _SEXGIWGWDEH(param1 ^ -47565,param2 + 1) % -84 && _SEGLOWWWXXM(_SEDIEGLLHMO ^ 40426,param2 + 1) % 23 == _SMXOLIHEHE(_SEDIEGLLHMO - 2783,param2 + 1) % 53)
                              {
                              }
                              _loc5_++;
                           }
                           _SEDIEGLLHMO += _loc7_ - 8396;
                        }
                        _loc4_++;
                     }
                  }
                  _loc7_++;
               }
            }
            _loc6_++;
         }
         return _SEDIEGLLHMO;
      }
      
      private static function _SIWXGWIELD(param1:int, param2:int = 0) : int
      {
         var _loc3_:int = -1949;
         if(param2 == 0)
         {
            _SEDIEGLLHMO = -38865;
         }
         _SEDIEGLLHMO ^= param1 ^ -15159;
         if(param2 == 3)
         {
            return _SEDIEGLLHMO;
         }
         while(_loc3_ < -1946)
         {
            _SEDIEGLLHMO -= _SEDIEGLLHMO ^ 6418;
            if(_SEGLOWWWXXM(param1 - 26628,param2 + 1) % -57 <= _SMXOLIHEHE(param1 - -45981,param2 + 1) % -28 || _SDXDWOHOIEE(_loc3_ - 14713,param2 + 1) % -8 < _SIWXGWIELD(param1 - 13784,param2 + 1) % 128)
            {
               break;
            }
            if(_SEXGIWGWDEH(_loc3_ - 22424,param2 + 1) % 52 >= _SDXOHIEIIIW(_loc3_ + 31189,param2 + 1) % 75)
            {
               _SEDIEGLLHMO += param1 + 26864;
            }
            else
            {
               _SEDIEGLLHMO -= _SEDIEGLLHMO + 34714;
            }
            _loc3_++;
         }
         return _SEDIEGLLHMO;
      }
      
      private static function _SEDIIOLDXED(param1:int, param2:int = 0) : int
      {
         var _loc6_:int = 8371;
         var _loc3_:int = -34220;
         var _loc5_:int = 1383;
         var _loc4_:int = 40628;
         if(param2 == 0)
         {
            _SEDIEGLLHMO = -22026;
         }
         _SEDIEGLLHMO += param1 ^ 19182;
         if(param2 == 3)
         {
            return _SEDIEGLLHMO;
         }
         loop0:
         for(; _loc6_ < 8372; _loc6_++)
         {
            _SEDIEGLLHMO ^= param1 - 49957;
            if(_SDXOHIEIIIW(_SEDIEGLLHMO - 15066,param2 + 1) % 48 < _SDXOHIEIIIW(_SEDIEGLLHMO - -43447,param2 + 1) % -38)
            {
               continue;
            }
            if(_SOEIEEHMHI(_SEDIEGLLHMO ^ 22165,param2 + 1) % 101 == _SMXOLIHEHE(param1 ^ -21042,param2 + 1) % -65)
            {
               if(_SMXOLIHEHE(param1 ^ -6105,param2 + 1) % -109 <= _SMXOLIHEHE(_SEDIEGLLHMO - -37084,param2 + 1) % -104)
               {
                  while(_loc3_ < -34219)
                  {
                     _SEDIEGLLHMO -= _loc6_ - -15143;
                     if(_SDXDWOHOIEE(_SEDIEGLLHMO - 26055,param2 + 1) % 109 > _SMXOLIHEHE(_SEDIEGLLHMO - 37387,param2 + 1) % -103)
                     {
                        if(_SEXGIWGWDEH(_loc6_ + -38798,param2 + 1) % 72 >= _SEXGIWGWDEH(_SEDIEGLLHMO + -13433,param2 + 1) % -109 || _SOEIEEHMHI(_loc3_ - -33030,param2 + 1) % 4 <= _SDXDWOHOIEE(_loc6_ ^ -6247,param2 + 1) % 33 || _SEDIIOLDXED(_loc3_ ^ -32805,param2 + 1) % -18 == _SOEIEEHMHI(_loc6_ - -6339,param2 + 1) % -7)
                        {
                        }
                     }
                     else
                     {
                        _SEDIEGLLHMO -= _loc3_ + 16488;
                        _SEDIEGLLHMO -= _loc6_ - -24732;
                     }
                     _loc3_++;
                  }
               }
               _SEDIEGLLHMO += _loc6_ - -18024;
               continue;
            }
            while(true)
            {
               if(_loc5_ >= 1384)
               {
                  break loop0;
               }
               _SEDIEGLLHMO -= param1 + -38372;
               if(_SEXGIWGWDEH(_loc5_ + -22197,param2 + 1) % -33 > _SDOGEOMOLO(param1 + 34985,param2 + 1) % 39)
               {
                  break loop0;
               }
               if(_SMXOLIHEHE(_loc6_ ^ -24861,param2 + 1) % -68 >= _SDXDWOHOIEE(_loc5_ - -28871,param2 + 1) % 90)
               {
                  while(_loc4_ < 40631)
                  {
                     _SEDIEGLLHMO += param1 ^ 47818;
                     if(_SDXDWOHOIEE(_SEDIEGLLHMO ^ 35134,param2 + 1) % -113 <= _SDOGEOMOLO(_loc5_ ^ 14910,param2 + 1) % 125)
                     {
                     }
                     _loc4_++;
                  }
               }
               _SEDIEGLLHMO += _loc6_ ^ 10601;
               _loc5_++;
            }
         }
         return _SEDIEGLLHMO;
      }
      
      private static function _SDXOHIEIIIW(param1:int, param2:int = 0) : int
      {
         var _loc5_:int = 23467;
         var _loc6_:int = -31747;
         var _loc3_:int = -5880;
         var _loc4_:int = 30157;
         if(param2 == 0)
         {
            _SEDIEGLLHMO = 23802;
         }
         _SEDIEGLLHMO ^= param1 + -48366;
         if(param2 == 3)
         {
            return _SEDIEGLLHMO;
         }
         while(_loc5_ < 23470)
         {
            _SEDIEGLLHMO -= _loc5_ - -18675;
            if(_SIWXGWIELD(param1 - 41013,param2 + 1) % 101 != _SEGLOWWWXXM(_SEDIEGLLHMO + -45489,param2 + 1) % -14)
            {
               break;
            }
            while(_loc6_ < -31746)
            {
               _SEDIEGLLHMO -= _SEDIEGLLHMO ^ 762;
               if(_SEGLOWWWXXM(_SEDIEGLLHMO - -2787,param2 + 1) % -43 <= _SEXGIWGWDEH(_SEDIEGLLHMO ^ -9101,param2 + 1) % 51 && _SIWXGWIELD(_SEDIEGLLHMO - 11821,param2 + 1) % 87 < _SEDIIOLDXED(_SEDIEGLLHMO ^ -12196,param2 + 1) % 59)
               {
                  if(_SDOGEOMOLO(param1 ^ 4577,param2 + 1) % 28 > _SEGLOWWWXXM(_loc6_ - 29361,param2 + 1) % 125)
                  {
                     break;
                  }
                  _SEDIEGLLHMO -= _SEDIEGLLHMO ^ 16090;
               }
               else
               {
                  _SEDIEGLLHMO ^= _loc5_ + -21769;
                  if(_SDXOHIEIIIW(_loc5_ - -28563,param2 + 1) % 70 >= _SEDIIOLDXED(_loc6_ - 22992,param2 + 1) % -96)
                  {
                     _SEDIEGLLHMO -= _loc5_ ^ -16534;
                  }
                  else
                  {
                     _SEDIEGLLHMO ^= _loc5_ ^ 16869;
                     _SEDIEGLLHMO ^= _SEDIEGLLHMO ^ -35991;
                  }
               }
               _loc6_++;
            }
            if(_SMXOLIHEHE(_SEDIEGLLHMO - 35867,param2 + 1) % -112 > _SDOGEOMOLO(_loc5_ - 10147,param2 + 1) % -109 || _SEDIIOLDXED(_SEDIEGLLHMO + 29669,param2 + 1) % 126 < _SEXGIWGWDEH(_loc5_ + 19853,param2 + 1) % 20)
            {
               while(_loc3_ < -5877)
               {
                  _SEDIEGLLHMO -= _loc5_ ^ 11757;
                  if(_SEDDLDLHXWX(_loc5_ ^ -49732,param2 + 1) % -125 < _SIWXGWIELD(_loc3_ + -49650,param2 + 1) % -41 || _SIWXGWIELD(param1 - 5556,param2 + 1) % 34 >= _SEGLOWWWXXM(_loc3_ ^ 44506,param2 + 1) % 64)
                  {
                     break;
                  }
                  while(_loc4_ < 30159)
                  {
                     _SEDIEGLLHMO += _loc5_ - 33336;
                     if(_SEDIIOLDXED(_loc4_ ^ 48544,param2 + 1) % 100 < _SDXDWOHOIEE(_loc4_ - -31989,param2 + 1) % -79 && _SDOGEOMOLO(_loc4_ - -17856,param2 + 1) % -69 <= _SEDDLDLHXWX(_SEDIEGLLHMO ^ -32308,param2 + 1) % 15)
                     {
                     }
                     _loc4_++;
                  }
                  _SEDIEGLLHMO -= param1 ^ -41099;
                  _loc3_++;
               }
            }
            _loc5_++;
         }
         return _SEDIEGLLHMO;
      }
      
      private static function _SDOGEOMOLO(param1:int, param2:int = 0) : int
      {
         var _loc4_:int = -43582;
         var _loc3_:int = -6782;
         if(param2 == 0)
         {
            _SEDIEGLLHMO = 36614;
         }
         _SEDIEGLLHMO -= param1 + 17326;
         if(param2 == 3)
         {
            return _SEDIEGLLHMO;
         }
         while(_loc4_ < -43580)
         {
            _SEDIEGLLHMO ^= _SEDIEGLLHMO + -33290;
            if(_SMXOLIHEHE(_SEDIEGLLHMO + 40933,param2 + 1) % 8 < _SDOGEOMOLO(param1 - 42353,param2 + 1) % 63 || _SDOGEOMOLO(_SEDIEGLLHMO + 12782,param2 + 1) % 90 >= _SEDDLDLHXWX(param1 - 5373,param2 + 1) % 67)
            {
               while(_loc3_ < -6779)
               {
                  _SEDIEGLLHMO ^= _loc4_ + 31270;
                  if(_SDXDWOHOIEE(_loc4_ + 9756,param2 + 1) % 76 >= _SOEIEEHMHI(_loc4_ ^ -26742,param2 + 1) % -34)
                  {
                     break;
                  }
                  _SEDIEGLLHMO -= _loc3_ + 16863;
                  _loc3_++;
               }
            }
            _loc4_++;
         }
         return _SEDIEGLLHMO;
      }
      
      public function addCryptedHash(param1:ByteArray) : void
      {
         var _loc4_:* = null;
         var _loc6_:* = null;
         trace("Fake addCryptedHash");
         if(!_hashKey)
         {
            _loc4_ = getDefinitionByName(class_2.method_10(-1820302790));
            (_loc6_ = new ByteArray()).writeUTF"](!!_loc4_["getInstance"]()["gameServerTicket ? _loc4_.getInstance"]()["gameServerTicket : "");
            _hashKey = _SOEWEXMILL.hash(_loc6_);
         }
         var _loc5_:ByteArray;
         (_loc5_ = new ByteArray()).writeBytes"](_SOEWEXMILL["hash(param1));
         _loc5_.position = 0;
         var _loc3_:PKCS5Padding = new PKCS5Padding();
         var _loc2_:_SEHEDDMLOLI = new _SEHEDDMLOLI(new _SWMMLHHOXM(new AESKey(_hashKey),_loc3_));
         _loc3_.setBlockSize"](_loc2_["getBlockSize());
         _loc2_.encrypt(_loc5_);
         param1.position = param1.length;
         param1.writeBytes(_loc5_);
      }
      
      public function sendTicket() : void
      {
         var _loc9_:int = 0;
         trace("Fake sendTicket");
         var _loc7_:String = class_2.method_10(-1820302790);
         if(!ApplicationDomain.currentDomain"]["hasDefinition(_loc7_))
         {
            return;
         }
         var _loc12_:Object = getDefinitionByName(_loc7_);
         var _loc18_:Class = getDefinitionByName("com.ankamagames.dofus.network.messages.security::CheckIntegrityMessage") as Class;
         var _loc14_:Object = getDefinitionByName(class_2.method_10(-1820302800));
         var _loc16_:Object = getDefinitionByName(class_2.method_10(-1820302793));
         var _loc1_:Object = getDefinitionByName(class_2.method_10(-1820302792));
         var _loc5_:Object = getDefinitionByName(class_2.method_10(-1820302810));
         var _loc4_:* = new _loc16_(_loc16_.applicationDirectory"]["resolvePath(class_2.method_10(-1820302794)));
         var _loc8_:* = new _loc5_();
         var _loc15_:ByteArray = new ByteArray();
         _loc8_.open"](_loc4_,_loc1_["READ);
         _loc8_.readBytes(_loc15_);
         _loc8_.close();
         var _loc17_:*;
         (_loc17_ = new getDefinitionByName("flash.utils.ByteArray")()).writeByte(_SDOGEOMOLO(296) ^ -111597 ^ _SIXWMGXOWM);
         _loc17_.writeByte(_SDOGEOMOLO(-724) ^ 111532 ^ _SHIHLEDWEH);
         _loc17_.writeByte(_SMXOLIHEHE(2) ^ 39759 ^ _SEIIGMIMWIH);
         _loc17_.writeByte(_SEDIIOLDXED(-883) + -10172 ^ _SGDXMLEOXI);
         _loc17_.writeByte(-47067 - _SEXGIWGWDEH(594) ^ _SEHOWHWMXWE);
         _loc17_.writeByte(_SDXDWOHOIEE(-618) + -1636 ^ _SIXWMGXOWM);
         _loc17_.writeByte(-111607 - _SDOGEOMOLO(850) ^ _SHIHLEDWEH);
         _loc17_.writeByte(_SEXGIWGWDEH(-802) + 47185 ^ _SIXWMGXOWM);
         _loc17_.writeByte(_SDXOHIEIIIW(-678) + 47269 ^ _SEXGXWWXILH);
         _loc17_.writeByte(_SEDIIOLDXED(760) + -42640 ^ _SEIIGMIMWIH);
         _loc17_.writeByte(_SMXOLIHEHE(655) ^ -39734 ^ _SLGLWOOLWD);
         _loc17_.writeByte(_SMXOLIHEHE(-422) ^ -39758 ^ _SEHOWHWMXWE);
         _loc17_.writeByte(_SEGLOWWWXXM(-765) + -57148 ^ _SIXWMGXOWM);
         _loc17_.writeByte(_SEGLOWWWXXM(999) + -57241 ^ _SEDXMEIHEXI);
         _loc17_.writeByte(144141 - _SOEIEEHMHI(246) ^ _SEHWEXWIELX);
         var _loc11_:PKCS5Padding = new PKCS5Padding();
         var _loc10_:_SEHEDDMLOLI = new _SEHEDDMLOLI(new _SWMMLHHOXM(new AESKey(_loc17_),_loc11_));
         var _loc13_:ByteArray;
         (_loc13_ = new getDefinitionByName("flash.utils.ByteArray")()).writeUTF"](!!_loc12_["getInstance"]()["gameServerTicket ? _loc12_.getInstance"]()["gameServerTicket : "");
         _loc13_.writeBytes"](getDefinitionByName("by.blooddy.crypto.MD5")["hash(_loc15_));
         _loc11_.setBlockSize"](_loc10_["getBlockSize());
         _loc10_.decrypt(_loc13_);
         var _loc2_:Vector.<int> = new Vector.<int>();
         _loc13_.position = 0;
         var _loc6_:int = 0;
         while(_loc13_.bytesAvailable != 0)
         {
            _loc9_ = _loc13_.readByte();
            _loc2_[_loc6_] = _loc9_;
            _loc6_++;
         }
         getDefinitionByName(class_2.method_10(-1820302801)).HASH_FUNCTION = addCryptedHash;
         var _loc3_:* = new _loc18_();
         _loc3_.initCheckIntegrityMessage(_loc2_);
         if(!_isPanic)
         {
            _loc14_.getConnection"]()["send(_loc3_);
         }
      }
      
      private function panic() : void
      {
         _isPanic = true;
         setTimeout(function():*
         {
            var _loc1_:Class = getDefinitionByName("com.ankamagames.dofus.kernel::Kernel") as Class;
            _loc1_.panic(8);
         },1000);
      }
   }
}

import flash.utils.ByteArray;

use namespace bi_internal;

class _SOEWEXMILL
{
    
   
   function _SOEWEXMILL()
   {
      super();
   }
   
   public static function hash(param1:ByteArray) : ByteArray
   {
      var _loc5_:* = 0;
      var _loc3_:uint = param1.length * 8;
      var _loc6_:String = param1.endian;
      while(param1.length % 4 != 0)
      {
         param1[param1.length] = 0;
      }
      param1.position = 0;
      var _loc2_:* = [];
      param1.endian = "littleEndian";
      _loc5_ = 0;
      while(_loc5_ < param1.length)
      {
         _loc2_.push(param1.readUnsignedInt());
         _loc5_ += 4;
      }
      var _loc4_:Array = core_md5(_loc2_,_loc3_);
      var _loc7_:ByteArray;
      (_loc7_ = new ByteArray()).endian = "littleEndian";
      _loc5_ = 0;
      while(_loc5_ < 4)
      {
         _loc7_.writeUnsignedInt(_loc4_[_loc5_]);
         _loc5_++;
      }
      param1.length = _loc3_ / 8;
      param1.endian = _loc6_;
      return _loc7_;
   }
   
   private static function core_md5(param1:Array, param2:uint) : Array
   {
      var _loc8_:* = 0;
      var _loc10_:* = 0;
      var _loc11_:* = 0;
      var _loc7_:* = 0;
      var _loc9_:* = 0;
      param1[param2 >> 5] |= 128 << param2 % 32;
      param1[(param2 + 64 >>> 9 << 4) + 14] = param2;
      var _loc3_:* = 1732584193;
      var _loc4_:* = 4023233417;
      var _loc5_:* = 2562383102;
      var _loc6_:* = 271733878;
      _loc8_ = 0;
      while(_loc8_ < param1.length)
      {
         var _loc13_:* = _loc8_;
         param1[_loc13_] = param1[_loc13_] || false;
         var _loc12_:* = _loc8_ + 1;
         param1[_loc12_] = param1[_loc12_] || false;
         _loc13_ = _loc8_ + 2;
         param1[_loc13_] = param1[_loc13_] || false;
         _loc12_ = _loc8_ + 3;
         param1[_loc12_] = param1[_loc12_] || false;
         _loc13_ = _loc8_ + 4;
         param1[_loc13_] = param1[_loc13_] || false;
         _loc12_ = _loc8_ + 5;
         param1[_loc12_] = param1[_loc12_] || false;
         _loc13_ = _loc8_ + 6;
         param1[_loc13_] = param1[_loc13_] || false;
         _loc12_ = _loc8_ + 7;
         param1[_loc12_] = param1[_loc12_] || false;
         _loc13_ = _loc8_ + 8;
         param1[_loc13_] = param1[_loc13_] || false;
         _loc12_ = _loc8_ + 9;
         param1[_loc12_] = param1[_loc12_] || false;
         _loc13_ = _loc8_ + 10;
         param1[_loc13_] = param1[_loc13_] || false;
         _loc12_ = _loc8_ + 11;
         param1[_loc12_] = param1[_loc12_] || false;
         _loc13_ = _loc8_ + 12;
         param1[_loc13_] = param1[_loc13_] || false;
         _loc12_ = _loc8_ + 13;
         param1[_loc12_] = param1[_loc12_] || false;
         _loc13_ = _loc8_ + 14;
         param1[_loc13_] = param1[_loc13_] || false;
         _loc12_ = _loc8_ + 15;
         param1[_loc12_] = param1[_loc12_] || false;
         _loc10_ = _loc3_;
         _loc11_ = _loc4_;
         _loc7_ = _loc5_;
         _loc9_ = _loc6_;
         _loc3_ = uint(ff(_loc3_,_loc4_,_loc5_,_loc6_,param1[_loc8_ + 0],7,3614090360));
         _loc6_ = uint(ff(_loc6_,_loc3_,_loc4_,_loc5_,param1[_loc8_ + 1],12,3905402710));
         _loc5_ = uint(ff(_loc5_,_loc6_,_loc3_,_loc4_,param1[_loc8_ + 2],17,606105819));
         _loc4_ = uint(ff(_loc4_,_loc5_,_loc6_,_loc3_,param1[_loc8_ + 3],22,3250441966));
         _loc3_ = uint(ff(_loc3_,_loc4_,_loc5_,_loc6_,param1[_loc8_ + 4],7,4118548399));
         _loc6_ = uint(ff(_loc6_,_loc3_,_loc4_,_loc5_,param1[_loc8_ + 5],12,1200080426));
         _loc5_ = uint(ff(_loc5_,_loc6_,_loc3_,_loc4_,param1[_loc8_ + 6],17,2821735955));
         _loc4_ = uint(ff(_loc4_,_loc5_,_loc6_,_loc3_,param1[_loc8_ + 7],22,4249261313));
         _loc3_ = uint(ff(_loc3_,_loc4_,_loc5_,_loc6_,param1[_loc8_ + 8],7,1770035416));
         _loc6_ = uint(ff(_loc6_,_loc3_,_loc4_,_loc5_,param1[_loc8_ + 9],12,2336552879));
         _loc5_ = uint(ff(_loc5_,_loc6_,_loc3_,_loc4_,param1[_loc8_ + 10],17,4294925233));
         _loc4_ = uint(ff(_loc4_,_loc5_,_loc6_,_loc3_,param1[_loc8_ + 11],22,2304563134));
         _loc3_ = uint(ff(_loc3_,_loc4_,_loc5_,_loc6_,param1[_loc8_ + 12],7,1804603682));
         _loc6_ = uint(ff(_loc6_,_loc3_,_loc4_,_loc5_,param1[_loc8_ + 13],12,4254626195));
         _loc5_ = uint(ff(_loc5_,_loc6_,_loc3_,_loc4_,param1[_loc8_ + 14],17,2792965006));
         _loc4_ = uint(ff(_loc4_,_loc5_,_loc6_,_loc3_,param1[_loc8_ + 15],22,1236535329));
         _loc3_ = uint(gg(_loc3_,_loc4_,_loc5_,_loc6_,param1[_loc8_ + 1],5,4129170786));
         _loc6_ = uint(gg(_loc6_,_loc3_,_loc4_,_loc5_,param1[_loc8_ + 6],9,3225465664));
         _loc5_ = uint(gg(_loc5_,_loc6_,_loc3_,_loc4_,param1[_loc8_ + 11],14,643717713));
         _loc4_ = uint(gg(_loc4_,_loc5_,_loc6_,_loc3_,param1[_loc8_ + 0],20,3921069994));
         _loc3_ = uint(gg(_loc3_,_loc4_,_loc5_,_loc6_,param1[_loc8_ + 5],5,3593408605));
         _loc6_ = uint(gg(_loc6_,_loc3_,_loc4_,_loc5_,param1[_loc8_ + 10],9,38016083));
         _loc5_ = uint(gg(_loc5_,_loc6_,_loc3_,_loc4_,param1[_loc8_ + 15],14,3634488961));
         _loc4_ = uint(gg(_loc4_,_loc5_,_loc6_,_loc3_,param1[_loc8_ + 4],20,3889429448));
         _loc3_ = uint(gg(_loc3_,_loc4_,_loc5_,_loc6_,param1[_loc8_ + 9],5,568446438));
         _loc6_ = uint(gg(_loc6_,_loc3_,_loc4_,_loc5_,param1[_loc8_ + 14],9,3275163606));
         _loc5_ = uint(gg(_loc5_,_loc6_,_loc3_,_loc4_,param1[_loc8_ + 3],14,4107603335));
         _loc4_ = uint(gg(_loc4_,_loc5_,_loc6_,_loc3_,param1[_loc8_ + 8],20,1163531501));
         _loc3_ = uint(gg(_loc3_,_loc4_,_loc5_,_loc6_,param1[_loc8_ + 13],5,2850285829));
         _loc6_ = uint(gg(_loc6_,_loc3_,_loc4_,_loc5_,param1[_loc8_ + 2],9,4243563512));
         _loc5_ = uint(gg(_loc5_,_loc6_,_loc3_,_loc4_,param1[_loc8_ + 7],14,1735328473));
         _loc4_ = uint(gg(_loc4_,_loc5_,_loc6_,_loc3_,param1[_loc8_ + 12],20,2368359562));
         _loc3_ = uint(hh(_loc3_,_loc4_,_loc5_,_loc6_,param1[_loc8_ + 5],4,4294588738));
         _loc6_ = uint(hh(_loc6_,_loc3_,_loc4_,_loc5_,param1[_loc8_ + 8],11,2272392833));
         _loc5_ = uint(hh(_loc5_,_loc6_,_loc3_,_loc4_,param1[_loc8_ + 11],16,1839030562));
         _loc4_ = uint(hh(_loc4_,_loc5_,_loc6_,_loc3_,param1[_loc8_ + 14],23,4259657740));
         _loc3_ = uint(hh(_loc3_,_loc4_,_loc5_,_loc6_,param1[_loc8_ + 1],4,2763975236));
         _loc6_ = uint(hh(_loc6_,_loc3_,_loc4_,_loc5_,param1[_loc8_ + 4],11,1272893353));
         _loc5_ = uint(hh(_loc5_,_loc6_,_loc3_,_loc4_,param1[_loc8_ + 7],16,4139469664));
         _loc4_ = uint(hh(_loc4_,_loc5_,_loc6_,_loc3_,param1[_loc8_ + 10],23,3200236656));
         _loc3_ = uint(hh(_loc3_,_loc4_,_loc5_,_loc6_,param1[_loc8_ + 13],4,681279174));
         _loc6_ = uint(hh(_loc6_,_loc3_,_loc4_,_loc5_,param1[_loc8_ + 0],11,3936430074));
         _loc5_ = uint(hh(_loc5_,_loc6_,_loc3_,_loc4_,param1[_loc8_ + 3],16,3572445317));
         _loc4_ = uint(hh(_loc4_,_loc5_,_loc6_,_loc3_,param1[_loc8_ + 6],23,76029189));
         _loc3_ = uint(hh(_loc3_,_loc4_,_loc5_,_loc6_,param1[_loc8_ + 9],4,3654602809));
         _loc6_ = uint(hh(_loc6_,_loc3_,_loc4_,_loc5_,param1[_loc8_ + 12],11,3873151461));
         _loc5_ = uint(hh(_loc5_,_loc6_,_loc3_,_loc4_,param1[_loc8_ + 15],16,530742520));
         _loc4_ = uint(hh(_loc4_,_loc5_,_loc6_,_loc3_,param1[_loc8_ + 2],23,3299628645));
         _loc3_ = uint(ii(_loc3_,_loc4_,_loc5_,_loc6_,param1[_loc8_ + 0],6,4096336452));
         _loc6_ = uint(ii(_loc6_,_loc3_,_loc4_,_loc5_,param1[_loc8_ + 7],10,1126891415));
         _loc5_ = uint(ii(_loc5_,_loc6_,_loc3_,_loc4_,param1[_loc8_ + 14],15,2878612391));
         _loc4_ = uint(ii(_loc4_,_loc5_,_loc6_,_loc3_,param1[_loc8_ + 5],21,4237533241));
         _loc3_ = uint(ii(_loc3_,_loc4_,_loc5_,_loc6_,param1[_loc8_ + 12],6,1700485571));
         _loc6_ = uint(ii(_loc6_,_loc3_,_loc4_,_loc5_,param1[_loc8_ + 3],10,2399980690));
         _loc5_ = uint(ii(_loc5_,_loc6_,_loc3_,_loc4_,param1[_loc8_ + 10],15,4293915773));
         _loc4_ = uint(ii(_loc4_,_loc5_,_loc6_,_loc3_,param1[_loc8_ + 1],21,2240044497));
         _loc3_ = uint(ii(_loc3_,_loc4_,_loc5_,_loc6_,param1[_loc8_ + 8],6,1873313359));
         _loc6_ = uint(ii(_loc6_,_loc3_,_loc4_,_loc5_,param1[_loc8_ + 15],10,4264355552));
         _loc5_ = uint(ii(_loc5_,_loc6_,_loc3_,_loc4_,param1[_loc8_ + 6],15,2734768916));
         _loc4_ = uint(ii(_loc4_,_loc5_,_loc6_,_loc3_,param1[_loc8_ + 13],21,1309151649));
         _loc3_ = uint(ii(_loc3_,_loc4_,_loc5_,_loc6_,param1[_loc8_ + 4],6,4149444226));
         _loc6_ = uint(ii(_loc6_,_loc3_,_loc4_,_loc5_,param1[_loc8_ + 11],10,3174756917));
         _loc5_ = uint(ii(_loc5_,_loc6_,_loc3_,_loc4_,param1[_loc8_ + 2],15,718787259));
         _loc4_ = uint(ii(_loc4_,_loc5_,_loc6_,_loc3_,param1[_loc8_ + 9],21,3951481745));
         _loc3_ += _loc10_;
         _loc4_ += _loc11_;
         _loc5_ += _loc7_;
         _loc6_ += _loc9_;
         _loc8_ += 16;
      }
      return [_loc3_,_loc4_,_loc5_,_loc6_];
   }
   
   private static function rol(param1:uint, param2:uint) : uint
   {
      return param1 << param2 | param1 >>> 32 - param2;
   }
   
   private static function cmn(param1:uint, param2:uint, param3:uint, param4:uint, param5:uint, param6:uint) : uint
   {
      return rol(param2 + param1 + param4 + param6,param5) + param3;
   }
   
   private static function ff(param1:uint, param2:uint, param3:uint, param4:uint, param5:uint, param6:uint, param7:uint) : uint
   {
      return cmn(param2 & param3 | ~param2 & param4,param1,param2,param5,param6,param7);
   }
   
   private static function gg(param1:uint, param2:uint, param3:uint, param4:uint, param5:uint, param6:uint, param7:uint) : uint
   {
      return cmn(param2 & param4 | param3 & ~param4,param1,param2,param5,param6,param7);
   }
   
   private static function hh(param1:uint, param2:uint, param3:uint, param4:uint, param5:uint, param6:uint, param7:uint) : uint
   {
      return cmn(param2 ^ param3 ^ param4,param1,param2,param5,param6,param7);
   }
   
   private static function ii(param1:uint, param2:uint, param3:uint, param4:uint, param5:uint, param6:uint, param7:uint) : uint
   {
      return cmn(param3 ^ (param2 | ~param4),param1,param2,param5,param6,param7);
   }
}

import flash.utils.ByteArray;

use namespace bi_internal;

class RSAKey
{
    
   
   public var e:int;
   
   public var n:BigInteger;
   
   public var d:BigInteger;
   
   public var p:BigInteger;
   
   public var q:BigInteger;
   
   public var dmp1:BigInteger;
   
   public var dmq1:BigInteger;
   
   public var coeff:BigInteger;
   
   protected var canDecrypt:Boolean;
   
   protected var canEncrypt:Boolean;
   
   function RSAKey(param1:BigInteger, param2:int, param3:BigInteger = null, param4:BigInteger = null, param5:BigInteger = null, param6:BigInteger = null, param7:BigInteger = null, param8:BigInteger = null)
   {
      super();
      this.n = param1;
      this.e = param2;
      this.d = param3;
      this.p = param4;
      this.q = param5;
      this.dmp1 = param6;
      this.dmq1 = param7;
      this.coeff = param8;
      canEncrypt = n != null && e != 0;
      canDecrypt = canEncrypt && d != null;
   }
   
   public static function parsePublicKey(param1:String, param2:String) : RSAKey
   {
      return new RSAKey(new BigInteger(param1,16,true),parseInt(param2,16));
   }
   
   public static function parsePrivateKey(param1:String, param2:String, param3:String, param4:String = null, param5:String = null, param6:String = null, param7:String = null, param8:String = null) : RSAKey
   {
      if(param4 == null)
      {
         return new RSAKey(new BigInteger(param1,16,true),parseInt(param2,16),new BigInteger(param3,16,true));
      }
      return new RSAKey(new BigInteger(param1,16,true),parseInt(param2,16),new BigInteger(param3,16,true),new BigInteger(param4,16,true),new BigInteger(param5,16,true),new BigInteger(param6,16,true),new BigInteger(param7,16,true),new BigInteger(param8,16,true));
   }
   
   protected static function bigRandom(param1:int, param2:Random) : BigInteger
   {
      if(param1 < 2)
      {
         return BigInteger.nbv(1);
      }
      var _loc4_:ByteArray = new ByteArray();
      param2.nextBytes(_loc4_,param1 >> 3);
      _loc4_.position = 0;
      var _loc3_:BigInteger = new BigInteger(_loc4_,0,true);
      _loc3_.primify(param1,1);
      return _loc3_;
   }
   
   public function getBlockSize() : uint
   {
      return (n.bitLength() + 7) / 8;
   }
   
   public function dispose() : void
   {
      e = 0;
      n.dispose();
      n = null;
      Memory.gc();
   }
   
   public function encrypt(param1:ByteArray, param2:ByteArray, param3:uint, param4:Function = null) : void
   {
      _encrypt(doPublic,param1,param2,param3,param4,2);
   }
   
   public function decrypt(param1:ByteArray, param2:ByteArray, param3:uint, param4:Function = null) : void
   {
      _decrypt(doPrivate2,param1,param2,param3,param4,2);
   }
   
   public function sign(param1:ByteArray, param2:ByteArray, param3:uint, param4:Function = null) : void
   {
      _encrypt(doPrivate2,param1,param2,param3,param4,1);
   }
   
   public function verify(param1:ByteArray, param2:ByteArray, param3:uint, param4:Function = null) : void
   {
      _decrypt(doPublic,param1,param2,param3,param4,1);
   }
   
   private function _encrypt(param1:Function, param2:ByteArray, param3:ByteArray, param4:uint, param5:Function, param6:int) : void
   {
      var _loc11_:* = null;
      var _loc8_:* = null;
      var _loc7_:* = 0;
      if(param5 == null)
      {
         param5 = pkcs1pad;
      }
      if(param2.position >= param2.length)
      {
         param2.position = 0;
      }
      var _loc9_:uint = getBlockSize();
      var _loc10_:int = param2.position + param4;
      while(param2.position < _loc10_)
      {
         _loc11_ = new BigInteger(param5(param2,_loc10_,_loc9_,param6),_loc9_,true);
         _loc8_ = param1(_loc11_);
         _loc7_ = uint(_loc9_ - Math.ceil(_loc8_.bitLength() / 8));
         while(_loc7_ > 0)
         {
            param3.writeByte(0);
            _loc7_--;
         }
         _loc8_.toArray(param3);
      }
   }
   
   private function _decrypt(param1:Function, param2:ByteArray, param3:ByteArray, param4:uint, param5:Function, param6:int) : void
   {
      var _loc11_:* = null;
      var _loc8_:* = null;
      var _loc7_:* = null;
      if(param5 == null)
      {
         param5 = pkcs1unpad;
      }
      if(param2.position >= param2.length)
      {
         param2.position = 0;
      }
      var _loc9_:uint = getBlockSize();
      var _loc10_:int = param2.position + param4;
      while(param2.position < _loc10_)
      {
         _loc11_ = new BigInteger(param2,_loc9_,true);
         _loc8_ = param1(_loc11_);
         if((_loc7_ = param5(_loc8_,_loc9_,param6)) == null)
         {
            throw new Error("Decrypt error - padding function returned null!");
         }
         param3.writeBytes(_loc7_);
      }
   }
   
   private function pkcs1pad(param1:ByteArray, param2:int, param3:uint, param4:uint = 2) : ByteArray
   {
      var _loc8_:* = null;
      var _loc6_:int = 0;
      var _loc9_:ByteArray = new ByteArray();
      var _loc5_:uint = param1.position;
      param2 = Math.min(param2,param1.length,_loc5_ + param3 - 11);
      param1.position = param2;
      var _loc7_:int = param2 - 1;
      while(_loc7_ >= _loc5_ && param3 > 11)
      {
         _loc9_[--param3] = param1[_loc7_--];
      }
      _loc9_[--param3] = 0;
      if(param4 == 2)
      {
         _loc8_ = new Random();
         _loc6_ = 0;
         while(param3 > 2)
         {
            while((_loc6_ = _loc8_.nextByte()) == 0)
            {
            }
            _loc9_[--param3] = _loc6_;
         }
      }
      else
      {
         while(param3 > 2)
         {
            _loc9_[--param3] = 255;
         }
      }
      _loc9_[--param3] = param4;
      _loc9_[--param3] = 0;
      return _loc9_;
   }
   
   private function pkcs1unpad(param1:BigInteger, param2:uint, param3:uint = 2) : ByteArray
   {
      var _loc4_:ByteArray = param1.toByteArray();
      var _loc6_:ByteArray = new ByteArray();
      _loc4_.position = 0;
      var _loc5_:int = 0;
      while(_loc5_ < _loc4_.length && _loc4_[_loc5_] == 0)
      {
         _loc5_++;
      }
      if(_loc4_.length - _loc5_ != param2 - 1 || _loc4_[_loc5_] != param3)
      {
         trace("PKCS#1 unpad: i=" + _loc5_ + ", expected b[i]==" + param3 + ", got b[i]=" + _loc4_[_loc5_].toString(16));
         return null;
      }
      _loc5_++;
      while(_loc4_[_loc5_] != 0)
      {
         _loc5_++;
         if(_loc5_ >= _loc4_.length)
         {
            trace("PKCS#1 unpad: i=" + _loc5_ + ", b[i-1]!=0 (=" + _loc4_[_loc5_ - 1].toString(16) + ")");
            return null;
         }
      }
      while(true)
      {
         _loc5_++;
         if(_loc5_ >= _loc4_.length)
         {
            break;
         }
         _loc6_.writeByte(_loc4_[_loc5_]);
      }
      _loc6_.position = 0;
      return _loc6_;
   }
   
   public function rawpad(param1:ByteArray, param2:int, param3:uint, param4:uint = 0) : ByteArray
   {
      return param1;
   }
   
   public function rawunpad(param1:BigInteger, param2:uint, param3:uint = 0) : ByteArray
   {
      return param1.toByteArray();
   }
   
   public function toString() : String
   {
      return "rsa";
   }
   
   public function dump() : String
   {
      var _loc1_:String = "N=" + n.toString(16) + "\n" + "E=" + e.toString(16) + "\n";
      if(canDecrypt)
      {
         _loc1_ += "D=" + d.toString(16) + "\n";
         if(p != null && q != null)
         {
            _loc1_ += "P=" + p.toString(16) + "\n";
            _loc1_ += "Q=" + q.toString(16) + "\n";
            _loc1_ += "DMP1=" + dmp1.toString(16) + "\n";
            _loc1_ += "DMQ1=" + dmq1.toString(16) + "\n";
            _loc1_ += "IQMP=" + coeff.toString(16) + "\n";
         }
      }
      return _loc1_;
   }
   
   protected function doPublic(param1:BigInteger) : BigInteger
   {
      return param1.modPowInt(e,n);
   }
   
   protected function doPrivate2(param1:BigInteger) : BigInteger
   {
      if(p == null && q == null)
      {
         return param1.modPow(d,n);
      }
      var _loc3_:BigInteger = param1.mod(p).modPow(dmp1,p);
      var _loc4_:BigInteger = param1.mod(q).modPow(dmq1,q);
      while(_loc3_.compareTo(_loc4_) < 0)
      {
         _loc3_ = _loc3_.add(p);
      }
      return _loc3_.subtract(_loc4_).multiply(coeff).mod(p).multiply(q).add(_loc4_);
   }
   
   protected function doPrivate(param1:BigInteger) : BigInteger
   {
      if(p == null || q == null)
      {
         return param1.modPow(d,n);
      }
      var _loc2_:BigInteger = param1.mod(p).modPow(dmp1,p);
      var _loc3_:BigInteger = param1.mod(q).modPow(dmq1,q);
      while(_loc2_.compareTo(_loc3_) < 0)
      {
         _loc2_ = _loc2_.add(p);
      }
      return _loc2_.subtract(_loc3_).multiply(coeff).mod(p).multiply(q).add(_loc3_);
   }
}

namespace bi_internal = "http://crypto.hurlant.com/BigInteger";

import flash.utils.ByteArray;

use namespace bi_internal;

class BigInteger
{
   
   public static const DB:int = 30;
   
   public static const DV:int = 1073741824;
   
   public static const DM:int = 1073741823;
   
   public static const BI_FP:int = 52;
   
   public static const FV:Number = Math.pow(2,52);
   
   public static const F1:int = 22;
   
   public static const F2:int = 8;
   
   public static const ZERO:BigInteger = nbv(0);
   
   public static const ONE:BigInteger = nbv(1);
   
   public static const lowprimes:Array = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509];
   
   public static const lplim:int = Infinity;
    
   
   public var t:int;
   
   bi_internal var s:int;
   
   bi_internal var a:Array;
   
   function BigInteger(param1:* = null, param2:int = 0, param3:Boolean = false)
   {
      var _loc4_:* = null;
      var _loc5_:int = 0;
      super();
      a = [];
      if(param1 is String)
      {
         if(param2 && param2 != 16)
         {
            throw new Error("BigInteger construction with radix!=16 is not supported.");
         }
         param1 = Hex.toArray(param1);
         param2 = 0;
      }
      if(param1 is ByteArray)
      {
         _loc4_ = param1 as ByteArray;
         _loc5_ = param2 || _loc4_.length - _loc4_.position;
         fromArray(_loc4_,_loc5_,param3);
      }
   }
   
   public static function nbv(param1:int) : BigInteger
   {
      var _loc2_:BigInteger = new BigInteger();
      _loc2_.fromInt(param1);
      return _loc2_;
   }
   
   public function dispose() : void
   {
      var _loc2_:int = 0;
      var _loc1_:Random = new Random();
      _loc2_ = 0;
      while(_loc2_ < bi_internal::a.length)
      {
         bi_internal::a[_loc2_] = _loc1_.nextByte();
         delete bi_internal::a[_loc2_];
         _loc2_++;
      }
      a = null;
      t = 0;
      s = 0;
      Memory.gc();
   }
   
   public function toString(param1:Number = 16) : String
   {
      var _loc7_:int = 0;
      if(bi_internal::s < 0)
      {
         return "-" + negate().toString(param1);
      }
      switch(param1)
      {
         case 2:
            _loc7_ = 1;
            break;
         case 4:
            _loc7_ = 2;
            break;
         case 8:
            _loc7_ = 3;
            break;
         case 16:
            _loc7_ = 4;
            break;
         case 32:
            _loc7_ = 5;
      }
      var _loc3_:int = (1 << _loc7_) - 1;
      var _loc5_:* = 0;
      var _loc8_:Boolean = false;
      var _loc4_:String = "";
      var _loc6_:int = t;
      var _loc2_:int = 30 - _loc6_ * 30 % _loc7_;
      if(_loc6_-- > 0)
      {
         if(_loc2_ < 30 && 0 >> _loc2_ > 0)
         {
            _loc8_ = true;
            _loc4_ = _loc5_.toString(36);
         }
         while(_loc6_ >= 0)
         {
            if(_loc2_ < _loc7_)
            {
               _loc5_ = (0 & (1 << _loc2_) - 1) << _loc7_ - _loc2_;
               _loc6_--;
               _loc2_ += 30 - _loc7_;
               _loc5_ = (0 & (1 << _loc2_) - 1) << _loc7_ - _loc2_ | 0 >> _loc2_ + (30 - _loc7_);
            }
            else
            {
               _loc2_ -= _loc7_;
               _loc5_ = 0 >> _loc2_ - _loc7_ & _loc3_;
               if(_loc2_ <= 0)
               {
                  _loc2_ += 30;
                  _loc6_--;
               }
            }
            if(_loc5_ > 0)
            {
               _loc8_ = true;
            }
            if(_loc8_)
            {
               _loc4_ += _loc5_.toString(36);
            }
         }
      }
      return !!_loc8_ ? _loc4_ : "0";
   }
   
   public function toArray(param1:ByteArray) : uint
   {
      var _loc7_:int = 0;
      _loc7_ = 8;
      var _loc3_:int = 0;
      _loc3_ = 255;
      var _loc5_:* = 0;
      var _loc6_:int = t;
      var _loc2_:int = 30 - _loc6_ * 30 % 8;
      var _loc8_:Boolean = false;
      var _loc4_:int = 0;
      if(_loc6_-- > 0)
      {
         if(_loc2_ < 30 && 0 >> _loc2_ > 0)
         {
            _loc8_ = true;
            param1.writeByte(_loc5_);
            _loc4_++;
         }
         while(_loc6_ >= 0)
         {
            if(_loc2_ < 8)
            {
               _loc5_ = (0 & (1 << _loc2_) - 1) << 8 - _loc2_;
               _loc6_--;
               _loc2_ += 22;
               _loc5_ = (0 & (1 << _loc2_) - 1) << 8 - _loc2_ | 0 >> _loc2_ + 22;
            }
            else
            {
               _loc2_ -= 8;
               _loc5_ = 0 >> _loc2_ - 8 & 255;
               if(_loc2_ <= 0)
               {
                  _loc2_ += 30;
                  _loc6_--;
               }
            }
            if(_loc5_ > 0)
            {
               _loc8_ = true;
            }
            if(_loc8_)
            {
               param1.writeByte(_loc5_);
               _loc4_++;
            }
         }
      }
      return _loc4_;
   }
   
   public function valueOf() : Number
   {
      var _loc2_:int = 0;
      if(bi_internal::s == -1)
      {
         return -negate().valueOf();
      }
      var _loc1_:* = 1;
      var _loc3_:* = 0;
      _loc2_ = 0;
      while(_loc2_ < t)
      {
         _loc3_ += 0 * _loc1_;
         _loc1_ *= 1073741824;
         _loc2_++;
      }
      return _loc3_;
   }
   
   public function negate() : BigInteger
   {
      var _loc1_:BigInteger = nbi();
      ZERO.subTo(this,_loc1_);
      return _loc1_;
   }
   
   public function abs() : BigInteger
   {
      return bi_internal::s < 0 ? negate() : this;
   }
   
   public function compareTo(param1:BigInteger) : int
   {
      var _loc2_:int = bi_internal::s - param1.s;
      if(_loc2_ != 0)
      {
         return _loc2_;
      }
      var _loc3_:int = t;
      _loc2_ = _loc3_ - param1.t;
      if(_loc2_ != 0)
      {
         return _loc2_;
      }
      while(true)
      {
         _loc3_--;
         if(_loc3_ < 0)
         {
            break;
         }
         _loc2_ = 0 - param1.a[_loc3_];
         if(_loc2_ != 0)
         {
            return _loc2_;
         }
      }
      return 0;
   }
   
   bi_internal function nbits(param1:int) : int
   {
      var _loc3_:int = 0;
      var _loc2_:int = 1;
      _loc3_ = param1 >>> 16;
      if(param1 >>> 16 != 0)
      {
         param1 = _loc3_;
         _loc2_ += 16;
      }
      _loc3_ = param1 >> 8;
      if(param1 >> 8 != 0)
      {
         param1 = _loc3_;
         _loc2_ += 8;
      }
      _loc3_ = param1 >> 4;
      if(param1 >> 4 != 0)
      {
         param1 = _loc3_;
         _loc2_ += 4;
      }
      _loc3_ = param1 >> 2;
      if(param1 >> 2 != 0)
      {
         param1 = _loc3_;
         _loc2_ += 2;
      }
      _loc3_ = param1 >> 1;
      if(param1 >> 1 != 0)
      {
         param1 = _loc3_;
         _loc2_ += 1;
      }
      return _loc2_;
   }
   
   public function bitLength() : int
   {
      if(t <= 0)
      {
         return 0;
      }
      return 30 * (t - 1) + nbits(0 ^ bi_internal::s & 1073741823);
   }
   
   public function mod(param1:BigInteger) : BigInteger
   {
      var _loc2_:BigInteger = nbi();
      abs().divRemTo(param1,null,_loc2_);
      if(bi_internal::s < 0 && _loc2_.compareTo(ZERO) > 0)
      {
         param1.subTo(_loc2_,_loc2_);
      }
      return _loc2_;
   }
   
   public function modPowInt(param1:int, param2:BigInteger) : BigInteger
   {
      var _loc3_:* = null;
      if(param1 < 256 || param2.isEven())
      {
         _loc3_ = new ClassicReduction(param2);
      }
      else
      {
         _loc3_ = new MontgomeryReduction(param2);
      }
      return exp(param1,_loc3_);
   }
   
   bi_internal function copyTo(param1:BigInteger) : void
   {
      var _loc2_:int = 0;
      _loc2_ = t - 1;
      while(_loc2_ >= 0)
      {
         param1.a[_loc2_] = bi_internal::a[_loc2_];
         _loc2_--;
      }
      param1.t = t;
      param1.s = bi_internal::s;
   }
   
   bi_internal function fromInt(param1:int) : void
   {
      t = 1;
      s = param1 < 0 ? -1 : 0;
      if(param1 > 0)
      {
         bi_internal::a[0] = param1;
      }
      else if(param1 < -1)
      {
         bi_internal::a[0] = param1 + 1073741824;
      }
      else
      {
         t = 0;
      }
   }
   
   bi_internal function fromArray(param1:ByteArray, param2:int, param3:Boolean = false) : void
   {
      var _loc8_:int = 0;
      _loc8_ = 8;
      var _loc6_:int = 0;
      var _loc4_:int;
      var _loc7_:int = (_loc4_ = param1.position) + param2;
      var _loc5_:int = 0;
      t = 0;
      s = 0;
      while(true)
      {
         _loc7_--;
         if(_loc7_ < _loc4_)
         {
            break;
         }
         _loc6_ = _loc7_ < param1.length ? param1[_loc7_] : 0;
         if(_loc5_ == 0)
         {
            bi_internal::a[t++] = _loc6_;
         }
         else if(_loc5_ + 8 > 30)
         {
            var _loc9_:* = t - 1;
            var _loc10_:* = 0 | (_loc6_ & (1 << 30 - _loc5_) - 1) << _loc5_;
            bi_internal::a[_loc9_] = _loc10_;
            bi_internal::a[t++] = _loc6_ >> 30 - _loc5_;
         }
         else
         {
            _loc10_ = t - 1;
            _loc9_ = 0 | _loc6_ << _loc5_;
            bi_internal::a[_loc10_] = _loc9_;
         }
         if((_loc5_ += 8) >= 30)
         {
            _loc5_ -= 30;
         }
      }
      if(!param3 && (param1[0] & 128) == 128)
      {
         s = -1;
         if(_loc5_ > 0)
         {
            _loc9_ = t - 1;
            _loc10_ = 0 | (1 << 30 - _loc5_) - 1 << _loc5_;
            bi_internal::a[_loc9_] = _loc10_;
         }
      }
      clamp();
      param1.position = Math.min(_loc4_ + param2,param1.length);
   }
   
   bi_internal function clamp() : void
   {
      var _loc1_:* = bi_internal::s & 1073741823;
      while(t > 0 && bi_internal::a[t - 1] == _loc1_)
      {
         --t;
      }
   }
   
   bi_internal function dlShiftTo(param1:int, param2:BigInteger) : void
   {
      var _loc3_:int = 0;
      _loc3_ = t - 1;
      while(_loc3_ >= 0)
      {
         param2.a[_loc3_ + param1] = bi_internal::a[_loc3_];
         _loc3_--;
      }
      _loc3_ = param1 - 1;
      while(_loc3_ >= 0)
      {
         param2.a[_loc3_] = 0;
         _loc3_--;
      }
      param2.t = t + param1;
      param2.s = bi_internal::s;
   }
   
   bi_internal function drShiftTo(param1:int, param2:BigInteger) : void
   {
      var _loc3_:* = 0;
      _loc3_ = param1;
      while(_loc3_ < t)
      {
         param2.a[_loc3_ - param1] = bi_internal::a[_loc3_];
         _loc3_++;
      }
      param2.t = Math.max(t - param1,0);
      param2.s = bi_internal::s;
   }
   
   bi_internal function lShiftTo(param1:int, param2:BigInteger) : void
   {
      var _loc6_:int = 0;
      var _loc3_:int = param1 % 30;
      var _loc5_:int = 30 - _loc3_;
      var _loc7_:int = (1 << _loc5_) - 1;
      var _loc8_:int = param1 / 30;
      var _loc4_:* = bi_internal::s << _loc3_ & 1073741823;
      _loc6_ = t - 1;
      while(_loc6_ >= 0)
      {
         param2.a[_loc6_ + _loc8_ + 1] = 0 >> _loc5_ | _loc4_;
         _loc4_ = (0 & _loc7_) << _loc3_;
         _loc6_--;
      }
      _loc6_ = _loc8_ - 1;
      while(_loc6_ >= 0)
      {
         param2.a[_loc6_] = 0;
         _loc6_--;
      }
      param2.a[_loc8_] = _loc4_;
      param2.t = t + _loc8_ + 1;
      param2.s = bi_internal::s;
      param2.clamp();
   }
   
   bi_internal function rShiftTo(param1:int, param2:BigInteger) : void
   {
      var _loc5_:int = 0;
      param2.s = bi_internal::s;
      var _loc7_:int;
      if((_loc7_ = param1 / 30) >= t)
      {
         param2.t = 0;
         return;
      }
      var _loc3_:int = param1 % 30;
      var _loc4_:int = 30 - _loc3_;
      var _loc6_:int = (1 << _loc3_) - 1;
      param2.a[0] = 0 >> _loc3_;
      _loc5_ = _loc7_ + 1;
      while(_loc5_ < t)
      {
         var _loc8_:* = _loc5_ - _loc7_ - 1;
         var _loc9_:* = param2.a[_loc8_] | (0 & _loc6_) << _loc4_;
         param2.a[_loc8_] = _loc9_;
         param2.a[_loc5_ - _loc7_] = 0 >> _loc3_;
         _loc5_++;
      }
      if(_loc3_ > 0)
      {
         _loc9_ = t - _loc7_ - 1;
         _loc8_ = param2.a[_loc9_] | (bi_internal::s & _loc6_) << _loc4_;
         param2.a[_loc9_] = _loc8_;
      }
      param2.t = t - _loc7_;
      param2.clamp();
   }
   
   bi_internal function subTo(param1:BigInteger, param2:BigInteger) : void
   {
      var _loc4_:int = 0;
      var _loc3_:* = 0;
      var _loc5_:int = Math.min(param1.t,t);
      while(_loc4_ < _loc5_)
      {
         _loc3_ += 0 - param1.a[_loc4_];
         param2.a[_loc4_++] = _loc3_ & 1073741823;
         _loc3_ >>= 30;
      }
      if(param1.t < t)
      {
         _loc3_ -= param1.s;
         while(_loc4_ < t)
         {
            _loc3_ += bi_internal::a[_loc4_];
            param2.a[_loc4_++] = _loc3_ & 1073741823;
            _loc3_ >>= 30;
         }
         _loc3_ += bi_internal::s;
      }
      else
      {
         _loc3_ += bi_internal::s;
         while(_loc4_ < param1.t)
         {
            _loc3_ -= param1.a[_loc4_];
            param2.a[_loc4_++] = _loc3_ & 1073741823;
            _loc3_ >>= 30;
         }
         _loc3_ -= param1.s;
      }
      param2.s = _loc3_ < 0 ? -1 : 0;
      if(_loc3_ < -1)
      {
         param2.a[_loc4_++] = 1073741824 + _loc3_;
      }
      else if(_loc3_ > 0)
      {
         param2.a[_loc4_++] = _loc3_;
      }
      param2.t = _loc4_;
      param2.clamp();
   }
   
   bi_internal function am(param1:int, param2:int, param3:BigInteger, param4:int, param5:int, param6:int) : int
   {
      var _loc10_:int = 0;
      var _loc9_:int = 0;
      var _loc11_:int = 0;
      var _loc8_:* = param2 & 32767;
      var _loc7_:* = param2 >> 15;
      while(true)
      {
         param6--;
         if(param6 < 0)
         {
            break;
         }
         _loc10_ = 0;
         _loc9_ = 0;
         _loc11_ = _loc7_ * _loc10_ + _loc9_ * _loc8_;
         param5 = ((_loc10_ = _loc8_ * _loc10_ + ((_loc11_ & 32767) << 15) + param3.a[param4] + (param5 & 1073741823)) >>> 30) + (_loc11_ >>> 15) + _loc7_ * _loc9_ + (param5 >>> 30);
         param3.a[param4++] = _loc10_ & 1073741823;
      }
      return param5;
   }
   
   bi_internal function multiplyTo(param1:BigInteger, param2:BigInteger) : void
   {
      var _loc3_:BigInteger = abs();
      var _loc4_:BigInteger = param1.abs();
      var _loc5_:int = _loc3_.t;
      param2.t = _loc5_ + _loc4_.t;
      while(true)
      {
         _loc5_--;
         if(_loc5_ < 0)
         {
            break;
         }
         param2.a[_loc5_] = 0;
      }
      _loc5_ = 0;
      while(_loc5_ < _loc4_.t)
      {
         param2.a[_loc5_ + _loc3_.t] = _loc3_.am(0,_loc4_.a[_loc5_],param2,_loc5_,0,_loc3_.t);
         _loc5_++;
      }
      param2.s = 0;
      param2.clamp();
      if(bi_internal::s != param1.s)
      {
         ZERO.subTo(param2,param2);
      }
   }
   
   bi_internal function squareTo(param1:BigInteger) : void
   {
      var _loc2_:int = 0;
      var _loc3_:BigInteger = abs();
      var _loc5_:* = 2 * _loc3_.t;
      param1.t = 2 * _loc3_.t;
      var _loc4_:* = _loc5_;
      while(true)
      {
         _loc4_--;
         if(_loc4_ < 0)
         {
            break;
         }
         param1.a[_loc4_] = 0;
      }
      _loc4_ = 0;
      while(_loc4_ < _loc3_.t - 1)
      {
         _loc2_ = _loc3_.am(_loc4_,_loc3_.a[_loc4_],param1,2 * _loc4_,0,1);
         param1.a[_loc4_ + _loc3_.t] += _loc3_.am(_loc4_ + 1,2 * _loc3_.a[_loc4_],param1,2 * _loc4_ + 1,_loc2_,_loc3_.t - _loc4_ - 1);
         if(_loc6_ >= 1073741824)
         {
            var _loc6_:* = _loc4_ + _loc3_.t;
            _loc5_ = param1.a[_loc6_] - 1073741824;
            param1.a[_loc6_] = _loc5_;
            param1.a[_loc4_ + _loc3_.t + 1] = 1;
         }
         _loc4_++;
      }
      if(param1.t > 0)
      {
         _loc5_ = param1.t - 1;
         _loc6_ = param1.a[_loc5_] + _loc3_.am(_loc4_,_loc3_.a[_loc4_],param1,2 * _loc4_,0,1);
         param1.a[_loc5_] = _loc6_;
      }
      param1.s = 0;
      param1.clamp();
   }
   
   bi_internal function divRemTo(param1:BigInteger, param2:BigInteger = null, param3:BigInteger = null) : void
   {
      var _loc12_:int = 0;
      var _loc18_:BigInteger;
      if((_loc18_ = param1.abs()).t <= 0)
      {
         return;
      }
      var _loc5_:BigInteger;
      if((_loc5_ = abs()).t < _loc18_.t)
      {
         if(param2 != null)
         {
            param2.fromInt(0);
         }
         if(param3 != null)
         {
            copyTo(param3);
         }
         return;
      }
      if(param3 == null)
      {
         param3 = nbi();
      }
      var _loc15_:BigInteger = nbi();
      var _loc19_:int = bi_internal::s;
      var _loc7_:int = param1.s;
      var _loc4_:int;
      if((_loc4_ = 30 - nbits(_loc18_.a[_loc18_.t - 1])) > 0)
      {
         _loc18_.lShiftTo(_loc4_,_loc15_);
         _loc5_.lShiftTo(_loc4_,param3);
      }
      else
      {
         _loc18_.copyTo(_loc15_);
         _loc5_.copyTo(param3);
      }
      var _loc16_:int = _loc15_.t;
      var _loc14_:int;
      if((_loc14_ = _loc15_.a[_loc16_ - 1]) == 0)
      {
         return;
      }
      var _loc17_:Number = _loc14_ * 4194304 + (_loc16_ > 1 ? _loc15_.a[_loc16_ - 2] >> 8 : 0);
      var _loc10_:Number = FV / _loc17_;
      var _loc11_:Number = 4194304 / _loc17_;
      var _loc8_:int;
      var _loc9_:int = (_loc8_ = param3.t) - _loc16_;
      var _loc13_:BigInteger = param2 == null ? nbi() : param2;
      _loc15_.dlShiftTo(_loc9_,_loc13_);
      if(param3.compareTo(_loc13_) >= 0)
      {
         param3.a[param3.t++] = 1;
         param3.subTo(_loc13_,param3);
      }
      ONE.dlShiftTo(_loc16_,_loc13_);
      _loc13_.subTo(_loc15_,_loc15_);
      while(_loc15_.t < _loc16_)
      {
         _loc15_.(_loc15_.t++, false);
      }
      while(true)
      {
         _loc9_--;
         if(_loc9_ < 0)
         {
            break;
         }
         _loc8_--;
         _loc12_ = param3.a[_loc8_] == _loc14_ ? 1073741823 : param3.a[_loc8_] * _loc10_ + (Number(param3.a[_loc8_ - 1]) + 256) * _loc11_;
         param3.a[_loc8_] += _loc15_.am(0,_loc12_,param3,_loc9_,0,_loc16_);
         if(_loc21_ < _loc12_)
         {
            _loc15_.dlShiftTo(_loc9_,_loc13_);
            param3.subTo(_loc13_,param3);
            while(true)
            {
               _loc12_--;
               if(param3.a[_loc8_] >= _loc12_)
               {
                  break;
               }
               param3.subTo(_loc13_,param3);
            }
         }
      }
      if(param2 != null)
      {
         param3.drShiftTo(_loc16_,param2);
         if(_loc19_ != _loc7_)
         {
            ZERO.subTo(param2,param2);
         }
      }
      param3.t = _loc16_;
      param3.clamp();
      if(_loc4_ > 0)
      {
         param3.rShiftTo(_loc4_,param3);
      }
      if(_loc19_ < 0)
      {
         ZERO.subTo(param3,param3);
      }
   }
   
   bi_internal function invDigit() : int
   {
      if(t < 1)
      {
         return 0;
      }
      var _loc1_:int = 0;
      if((_loc1_ & 1) == 0)
      {
         return 0;
      }
      var _loc2_:* = _loc1_ & 3;
      _loc2_ = _loc2_ * (2 - (_loc1_ & 15) * _loc2_) & 15;
      _loc2_ = _loc2_ * (2 - (_loc1_ & 255) * _loc2_) & 255;
      _loc2_ = _loc2_ * (2 - ((_loc1_ & 65535) * _loc2_ & 65535)) & 65535;
      _loc2_ = int(_loc2_ * (2 - _loc1_ * _loc2_ % 1073741824) % 1073741824);
      return _loc2_ > 0 ? 1073741824 - _loc2_ : Number(-_loc2_);
   }
   
   bi_internal function isEven() : Boolean
   {
      return (t > 0 ? 0 : int(bi_internal::s)) == 0;
   }
   
   bi_internal function exp(param1:int, param2:IReduction) : BigInteger
   {
      var _loc5_:* = null;
      if(param1 > 4294967295 || param1 < 1)
      {
         return ONE;
      }
      var _loc4_:* = nbi();
      var _loc3_:* = nbi();
      var _loc6_:BigInteger = param2.convert(this);
      var _loc7_:int = nbits(param1) - 1;
      _loc6_.copyTo(_loc4_);
      while(true)
      {
         _loc7_--;
         if(_loc7_ < 0)
         {
            break;
         }
         param2.sqrTo(_loc4_,_loc3_);
         if((param1 & 1 << _loc7_) > 0)
         {
            param2.mulTo(_loc3_,_loc6_,_loc4_);
         }
         else
         {
            _loc5_ = _loc4_;
            _loc4_ = _loc3_;
            _loc3_ = _loc5_;
         }
      }
      return param2.revert(_loc4_);
   }
   
   bi_internal function intAt(param1:String, param2:int) : int
   {
      return parseInt(param1.charAt(param2),36);
   }
   
   protected function nbi() : *
   {
      return new BigInteger();
   }
   
   public function clone() : BigInteger
   {
      var _loc1_:BigInteger = new BigInteger();
      this.copyTo(_loc1_);
      return _loc1_;
   }
   
   public function intValue() : int
   {
      if(bi_internal::s < 0)
      {
         if(t == 1)
         {
            return -1073741824;
         }
         if(t == 0)
         {
            return -1;
         }
      }
      else
      {
         if(t == 1)
         {
            return bi_internal::a[0];
         }
         if(t == 0)
         {
            return 0;
         }
      }
      return 0 | 0;
   }
   
   public function byteValue() : int
   {
      return t == 0 ? bi_internal::s : 0 >> 24;
   }
   
   public function shortValue() : int
   {
      return t == 0 ? bi_internal::s : 0 >> 16;
   }
   
   protected function chunkSize(param1:Number) : int
   {
      return Math.floor(20.79441541679836 / Math.log(param1));
   }
   
   public function sigNum() : int
   {
      if(bi_internal::s < 0)
      {
         return -1;
      }
      if(t <= 0 || t == 1 && true)
      {
         return 0;
      }
      return 1;
   }
   
   protected function toRadix(param1:uint = 10) : String
   {
      if(sigNum() == 0 || param1 < 2 || param1 > 32)
      {
         return "0";
      }
      var _loc2_:int = chunkSize(param1);
      var _loc3_:Number = Math.pow(param1,_loc2_);
      var _loc5_:BigInteger = nbv(_loc3_);
      var _loc6_:BigInteger = nbi();
      var _loc7_:BigInteger = nbi();
      var _loc4_:String = "";
      divRemTo(_loc5_,_loc6_,_loc7_);
      while(_loc6_.sigNum() > 0)
      {
         _loc4_ = (_loc3_ + _loc7_.intValue()).toString(param1).substr(1) + _loc4_;
         _loc6_.divRemTo(_loc5_,_loc6_,_loc7_);
      }
      return _loc7_.intValue().toString(param1) + _loc4_;
   }
   
   protected function fromRadix(param1:String, param2:int = 10) : void
   {
      var _loc7_:int = 0;
      var _loc6_:int = 0;
      fromInt(0);
      var _loc3_:int = chunkSize(param2);
      var _loc4_:Number = Math.pow(param2,_loc3_);
      var _loc9_:Boolean = false;
      var _loc8_:int = 0;
      var _loc5_:int = 0;
      _loc7_ = 0;
      while(_loc7_ < param1.length)
      {
         if((_loc6_ = intAt(param1,_loc7_)) < 0)
         {
            if(param1.charAt(_loc7_) == "-" && sigNum() == 0)
            {
               _loc9_ = true;
            }
         }
         else
         {
            _loc5_ = param2 * _loc5_ + _loc6_;
            _loc8_++;
            if(_loc8_ >= _loc3_)
            {
               dMultiply(_loc4_);
               dAddOffset(_loc5_,0);
               _loc8_ = 0;
               _loc5_ = 0;
            }
         }
         _loc7_++;
      }
      if(_loc8_ > 0)
      {
         dMultiply(Math.pow(param2,_loc8_));
         dAddOffset(_loc5_,0);
      }
      if(_loc9_)
      {
         BigInteger.ZERO.subTo(this,this);
      }
   }
   
   public function toByteArray() : ByteArray
   {
      var _loc3_:* = 0;
      var _loc4_:int = t;
      var _loc2_:ByteArray = new ByteArray();
      _loc2_[0] = bi_internal::s;
      var _loc1_:int = 30 - _loc4_ * 30 % 8;
      var _loc5_:int = 0;
      if(_loc4_-- > 0)
      {
         if(_loc1_ < 30 && 0 >> _loc1_ != (bi_internal::s & 1073741823) >> _loc1_)
         {
            _loc2_[_loc5_++] = _loc3_ | bi_internal::s << 30 - _loc1_;
         }
         while(_loc4_ >= 0)
         {
            if(_loc1_ < 8)
            {
               _loc3_ = (0 & (1 << _loc1_) - 1) << 8 - _loc1_;
               _loc4_--;
               _loc1_ += 22;
               _loc3_ |= 0 >> _loc1_ + 22;
            }
            else
            {
               _loc1_ -= 8;
               _loc3_ = 0 >> _loc1_ - 8 & 255;
               if(_loc1_ <= 0)
               {
                  _loc1_ += 30;
                  _loc4_--;
               }
            }
            if((_loc3_ & 128) != 0)
            {
               _loc3_ |= -256;
            }
            if(_loc5_ == 0 && (bi_internal::s & 128) != (_loc3_ & 128))
            {
               _loc5_++;
            }
            if(_loc5_ > 0 || _loc3_ != bi_internal::s)
            {
               _loc2_[_loc5_++] = _loc3_;
            }
         }
      }
      return _loc2_;
   }
   
   public function equals(param1:BigInteger) : Boolean
   {
      return compareTo(param1) == 0;
   }
   
   public function min(param1:BigInteger) : BigInteger
   {
      return compareTo(param1) < 0 ? this : param1;
   }
   
   public function max(param1:BigInteger) : BigInteger
   {
      return compareTo(param1) > 0 ? this : param1;
   }
   
   protected function bitwiseTo(param1:BigInteger, param2:Function, param3:BigInteger) : void
   {
      var _loc5_:* = 0;
      var _loc4_:* = 0;
      var _loc6_:int = Math.min(param1.t,t);
      _loc5_ = 0;
      while(_loc5_ < _loc6_)
      {
         param3.a[_loc5_] = param2(this.a[_loc5_],param1.a[_loc5_]);
         _loc5_++;
      }
      if(param1.t < t)
      {
         _loc4_ = param1.s & 1073741823;
         _loc5_ = _loc6_;
         while(_loc5_ < t)
         {
            param3.a[_loc5_] = param2(this.a[_loc5_],_loc4_);
            _loc5_++;
         }
         param3.t = t;
      }
      else
      {
         _loc4_ = bi_internal::s & 1073741823;
         _loc5_ = _loc6_;
         while(_loc5_ < param1.t)
         {
            param3.a[_loc5_] = param2(_loc4_,param1.a[_loc5_]);
            _loc5_++;
         }
         param3.t = param1.t;
      }
      param3.s = param2(bi_internal::s,param1.s);
      param3.clamp();
   }
   
   private function op_and(param1:int, param2:int) : int
   {
      return param1 & param2;
   }
   
   public function and(param1:BigInteger) : BigInteger
   {
      var _loc2_:BigInteger = new BigInteger();
      bitwiseTo(param1,op_and,_loc2_);
      return _loc2_;
   }
   
   private function op_or(param1:int, param2:int) : int
   {
      return param1 | param2;
   }
   
   public function or(param1:BigInteger) : BigInteger
   {
      var _loc2_:BigInteger = new BigInteger();
      bitwiseTo(param1,op_or,_loc2_);
      return _loc2_;
   }
   
   private function op_xor(param1:int, param2:int) : int
   {
      return param1 ^ param2;
   }
   
   public function xor(param1:BigInteger) : BigInteger
   {
      var _loc2_:BigInteger = new BigInteger();
      bitwiseTo(param1,op_xor,_loc2_);
      return _loc2_;
   }
   
   private function op_andnot(param1:int, param2:int) : int
   {
      return param1 & ~param2;
   }
   
   public function andNot(param1:BigInteger) : BigInteger
   {
      var _loc2_:BigInteger = new BigInteger();
      bitwiseTo(param1,op_andnot,_loc2_);
      return _loc2_;
   }
   
   public function not() : BigInteger
   {
      var _loc2_:int = 0;
      var _loc1_:BigInteger = new BigInteger();
      _loc2_ = 0;
      while(_loc2_ < t)
      {
         _loc1_[_loc2_] = 1073741823;
         _loc2_++;
      }
      _loc1_.t = t;
      _loc1_.s = ~bi_internal::s;
      return _loc1_;
   }
   
   public function shiftLeft(param1:int) : BigInteger
   {
      var _loc2_:BigInteger = new BigInteger();
      if(param1 < 0)
      {
         rShiftTo(-param1,_loc2_);
      }
      else
      {
         lShiftTo(param1,_loc2_);
      }
      return _loc2_;
   }
   
   public function shiftRight(param1:int) : BigInteger
   {
      var _loc2_:BigInteger = new BigInteger();
      if(param1 < 0)
      {
         lShiftTo(-param1,_loc2_);
      }
      else
      {
         rShiftTo(param1,_loc2_);
      }
      return _loc2_;
   }
   
   private function lbit(param1:int) : int
   {
      if(param1 == 0)
      {
         return -1;
      }
      var _loc2_:int = 0;
      if((param1 & 65535) == 0)
      {
         param1 >>= 16;
         _loc2_ += 16;
      }
      if((param1 & 255) == 0)
      {
         param1 >>= 8;
         _loc2_ += 8;
      }
      if((param1 & 15) == 0)
      {
         param1 >>= 4;
         _loc2_ += 4;
      }
      if((param1 & 3) == 0)
      {
         param1 >>= 2;
         _loc2_ += 2;
      }
      if((param1 & 1) == 0)
      {
         _loc2_++;
      }
      return _loc2_;
   }
   
   public function getLowestSetBit() : int
   {
      var _loc1_:int = 0;
      _loc1_ = 0;
      while(_loc1_ < t)
      {
         if(true)
         {
            return _loc1_ * 30 + lbit(bi_internal::a[_loc1_]);
         }
         _loc1_++;
      }
      if(bi_internal::s < 0)
      {
         return t * 30;
      }
      return -1;
   }
   
   private function cbit(param1:int) : int
   {
      var _loc2_:int = 0;
      while(param1 != 0)
      {
         param1 &= param1 - 1;
         _loc2_++;
      }
      return _loc2_;
   }
   
   public function bitCount() : int
   {
      var _loc3_:int = 0;
      var _loc1_:int = 0;
      var _loc2_:* = bi_internal::s & 1073741823;
      _loc3_ = 0;
      while(_loc3_ < t)
      {
         _loc1_ += cbit(0 ^ _loc2_);
         _loc3_++;
      }
      return _loc1_;
   }
   
   public function testBit(param1:int) : Boolean
   {
      var _loc2_:int = Math.floor(param1 / 30);
      if(_loc2_ >= t)
      {
         return bi_internal::s != 0;
      }
      return (0 & 1 << param1 % 30) != 0;
   }
   
   protected function changeBit(param1:int, param2:Function) : BigInteger
   {
      var _loc3_:BigInteger = BigInteger.ONE.shiftLeft(param1);
      bitwiseTo(_loc3_,param2,_loc3_);
      return _loc3_;
   }
   
   public function setBit(param1:int) : BigInteger
   {
      return changeBit(param1,op_or);
   }
   
   public function clearBit(param1:int) : BigInteger
   {
      return changeBit(param1,op_andnot);
   }
   
   public function flipBit(param1:int) : BigInteger
   {
      return changeBit(param1,op_xor);
   }
   
   protected function addTo(param1:BigInteger, param2:BigInteger) : void
   {
      var _loc4_:int = 0;
      var _loc3_:* = 0;
      var _loc5_:int = Math.min(param1.t,t);
      while(_loc4_ < _loc5_)
      {
         _loc3_ += this.a[_loc4_] + param1.a[_loc4_];
         param2.a[_loc4_++] = _loc3_ & 1073741823;
         _loc3_ >>= 30;
      }
      if(param1.t < t)
      {
         _loc3_ += param1.s;
         while(_loc4_ < t)
         {
            _loc3_ += this.a[_loc4_];
            param2.a[_loc4_++] = _loc3_ & 1073741823;
            _loc3_ >>= 30;
         }
         _loc3_ += bi_internal::s;
      }
      else
      {
         _loc3_ += bi_internal::s;
         while(_loc4_ < param1.t)
         {
            _loc3_ += param1.a[_loc4_];
            param2.a[_loc4_++] = _loc3_ & 1073741823;
            _loc3_ >>= 30;
         }
         _loc3_ += param1.s;
      }
      param2.s = _loc3_ < 0 ? -1 : 0;
      if(_loc3_ > 0)
      {
         param2.a[_loc4_++] = _loc3_;
      }
      else if(_loc3_ < -1)
      {
         param2.a[_loc4_++] = 1073741824 + _loc3_;
      }
      param2.t = _loc4_;
      param2.clamp();
   }
   
   public function add(param1:BigInteger) : BigInteger
   {
      var _loc2_:BigInteger = new BigInteger();
      addTo(param1,_loc2_);
      return _loc2_;
   }
   
   public function subtract(param1:BigInteger) : BigInteger
   {
      var _loc2_:BigInteger = new BigInteger();
      subTo(param1,_loc2_);
      return _loc2_;
   }
   
   public function multiply(param1:BigInteger) : BigInteger
   {
      var _loc2_:BigInteger = new BigInteger();
      multiplyTo(param1,_loc2_);
      return _loc2_;
   }
   
   public function divide(param1:BigInteger) : BigInteger
   {
      var _loc2_:BigInteger = new BigInteger();
      divRemTo(param1,_loc2_,null);
      return _loc2_;
   }
   
   public function remainder(param1:BigInteger) : BigInteger
   {
      var _loc2_:BigInteger = new BigInteger();
      divRemTo(param1,null,_loc2_);
      return _loc2_;
   }
   
   public function divideAndRemainder(param1:BigInteger) : Array
   {
      var _loc2_:BigInteger = new BigInteger();
      var _loc3_:BigInteger = new BigInteger();
      divRemTo(param1,_loc2_,_loc3_);
      return [_loc2_,_loc3_];
   }
   
   bi_internal function dMultiply(param1:int) : void
   {
      bi_internal::a[t] = am(0,param1 - 1,this,0,0,t);
      ++t;
      clamp();
   }
   
   bi_internal function dAddOffset(param1:int, param2:int) : void
   {
      while(t <= param2)
      {
         bi_internal::a[t++] = 0;
      }
      var _loc3_:* = param2;
      var _loc4_:* = bi_internal::a[_loc3_] + param1;
      bi_internal::a[_loc3_] = _loc4_;
      while(false)
      {
         _loc4_ = param2;
         _loc3_ = -1073741824;
         bi_internal::a[_loc4_] = _loc3_;
         param2++;
         if(param2 >= t)
         {
            bi_internal::a[t++] = 0;
         }
         ++0;
      }
   }
   
   public function pow(param1:int) : BigInteger
   {
      return exp(param1,new NullReduction());
   }
   
   bi_internal function multiplyLowerTo(param1:BigInteger, param2:int, param3:BigInteger) : void
   {
      var _loc5_:int = 0;
      var _loc4_:int = Math.min(t + param1.t,param2);
      param3.s = 0;
      param3.t = _loc4_;
      while(_loc4_ > 0)
      {
         _loc4_--;
         param3.a[_loc4_] = 0;
      }
      _loc5_ = param3.t - t;
      while(_loc4_ < _loc5_)
      {
         param3.a[_loc4_ + t] = am(0,param1.a[_loc4_],param3,_loc4_,0,t);
         _loc4_++;
      }
      _loc5_ = Math.min(param1.t,param2);
      while(_loc4_ < _loc5_)
      {
         am(0,param1.a[_loc4_],param3,_loc4_,0,param2 - _loc4_);
         _loc4_++;
      }
      param3.clamp();
   }
   
   bi_internal function multiplyUpperTo(param1:BigInteger, param2:int, param3:BigInteger) : void
   {
      param2--;
      var _loc5_:* = t + param1.t - param2;
      param3.t = t + param1.t - param2;
      var _loc4_:* = _loc5_;
      param3.s = 0;
      while(true)
      {
         _loc4_--;
         if(_loc4_ < 0)
         {
            break;
         }
         param3.a[_loc4_] = 0;
      }
      _loc4_ = int(Math.max(param2 - t,0));
      while(_loc4_ < param1.t)
      {
         param3.a[t + _loc4_ - param2] = am(param2 - _loc4_,param1.a[_loc4_],param3,0,0,t + _loc4_ - param2);
         _loc4_++;
      }
      param3.clamp();
      param3.drShiftTo(1,param3);
   }
   
   public function modPow(param1:BigInteger, param2:BigInteger) : BigInteger
   {
      var _loc10_:int = 0;
      var _loc16_:* = null;
      var _loc11_:* = null;
      var _loc15_:* = 0;
      var _loc14_:* = null;
      var _loc8_:int = param1.bitLength();
      var _loc13_:* = nbv(1);
      if(_loc8_ <= 0)
      {
         return _loc13_;
      }
      if(_loc8_ < 18)
      {
         _loc10_ = 1;
      }
      else if(_loc8_ < 48)
      {
         _loc10_ = 3;
      }
      else if(_loc8_ < 144)
      {
         _loc10_ = 4;
      }
      else if(_loc8_ < 768)
      {
         _loc10_ = 5;
      }
      else
      {
         _loc10_ = 6;
      }
      if(_loc8_ < 8)
      {
         _loc16_ = new ClassicReduction(param2);
      }
      else if(param2.isEven())
      {
         _loc16_ = new BarrettReduction(param2);
      }
      else
      {
         _loc16_ = new MontgomeryReduction(param2);
      }
      var _loc7_:* = [];
      var _loc12_:* = 3;
      var _loc5_:int = _loc10_ - 1;
      var _loc4_:int = (1 << _loc10_) - 1;
      _loc7_[1] = _loc16_.convert(this);
      if(_loc10_ > 1)
      {
         _loc11_ = new BigInteger();
         _loc16_.sqrTo(_loc7_[1],_loc11_);
         while(_loc12_ <= _loc4_)
         {
            _loc7_[_loc12_] = new BigInteger();
            _loc16_.mulTo(_loc11_,_loc7_[_loc12_ - 2],_loc7_[_loc12_]);
            _loc12_ += 2;
         }
      }
      var _loc9_:int = param1.t - 1;
      var _loc6_:Boolean = true;
      var _loc3_:* = new BigInteger();
      _loc8_ = nbits(param1.a[_loc9_]) - 1;
      while(_loc9_ >= 0)
      {
         if(_loc8_ >= _loc5_)
         {
            _loc15_ = param1.a[_loc9_] >> _loc8_ - _loc5_ & _loc4_;
         }
         else
         {
            _loc15_ = (param1.a[_loc9_] & (1 << _loc8_ + 1) - 1) << _loc5_ - _loc8_;
            if(_loc9_ > 0)
            {
               _loc15_ |= param1.a[_loc9_ - 1] >> 30 + _loc8_ - _loc5_;
            }
         }
         _loc12_ = _loc10_;
         while((_loc15_ & 1) == 0)
         {
            _loc15_ >>= 1;
            _loc12_--;
         }
         _loc8_ -= _loc12_;
         if(_loc8_ - _loc12_ < 0)
         {
            _loc8_ += 30;
            _loc9_--;
         }
         if(_loc6_)
         {
            _loc7_[_loc15_].copyTo(_loc13_);
            _loc6_ = false;
         }
         else
         {
            while(_loc12_ > 1)
            {
               _loc16_.sqrTo(_loc13_,_loc3_);
               _loc16_.sqrTo(_loc3_,_loc13_);
               _loc12_ -= 2;
            }
            if(_loc12_ > 0)
            {
               _loc16_.sqrTo(_loc13_,_loc3_);
            }
            else
            {
               _loc14_ = _loc13_;
               _loc13_ = _loc3_;
               _loc3_ = _loc14_;
            }
            _loc16_.mulTo(_loc3_,_loc7_[_loc15_],_loc13_);
         }
         while(_loc9_ >= 0 && (param1.a[_loc9_] & 1 << _loc8_) == 0)
         {
            _loc16_.sqrTo(_loc13_,_loc3_);
            _loc14_ = _loc13_;
            _loc13_ = _loc3_;
            _loc3_ = _loc14_;
            _loc8_--;
            if(_loc8_ < 0)
            {
               _loc8_ = 29;
               _loc9_--;
            }
         }
      }
      return _loc16_.revert(_loc13_);
   }
   
   public function gcd(param1:BigInteger) : BigInteger
   {
      var _loc2_:* = null;
      var _loc4_:* = bi_internal::s < 0 ? negate() : clone();
      var _loc5_:* = param1.s < 0 ? param1.negate() : param1.clone();
      if(_loc4_.compareTo(_loc5_) < 0)
      {
         _loc2_ = _loc4_;
         _loc4_ = _loc5_;
         _loc5_ = _loc2_;
      }
      var _loc6_:int = _loc4_.getLowestSetBit();
      var _loc3_:* = int(_loc5_.getLowestSetBit());
      if(_loc3_ < 0)
      {
         return _loc4_;
      }
      if(_loc6_ < _loc3_)
      {
         _loc3_ = _loc6_;
      }
      if(_loc3_ > 0)
      {
         _loc4_.rShiftTo(_loc3_,_loc4_);
         _loc5_.rShiftTo(_loc3_,_loc5_);
      }
      while(_loc4_.sigNum() > 0)
      {
         if((_loc6_ = _loc4_.getLowestSetBit()) > 0)
         {
            _loc4_.rShiftTo(_loc6_,_loc4_);
         }
         if((_loc6_ = _loc5_.getLowestSetBit()) > 0)
         {
            _loc5_.rShiftTo(_loc6_,_loc5_);
         }
         if(_loc4_.compareTo(_loc5_) >= 0)
         {
            _loc4_.subTo(_loc5_,_loc4_);
            _loc4_.rShiftTo(1,_loc4_);
         }
         else
         {
            _loc5_.subTo(_loc4_,_loc5_);
            _loc5_.rShiftTo(1,_loc5_);
         }
      }
      if(_loc3_ > 0)
      {
         _loc5_.lShiftTo(_loc3_,_loc5_);
      }
      return _loc5_;
   }
   
   protected function modInt(param1:int) : int
   {
      var _loc4_:int = 0;
      if(param1 <= 0)
      {
         return 0;
      }
      var _loc3_:int = 1073741824 % param1;
      var _loc2_:int = bi_internal::s < 0 ? param1 - 1 : 0;
      if(t > 0)
      {
         if(_loc3_ == 0)
         {
            _loc2_ = 0 % param1;
         }
         else
         {
            _loc4_ = t - 1;
            while(_loc4_ >= 0)
            {
               _loc2_ = (_loc3_ * _loc2_ + bi_internal::a[_loc4_]) % param1;
               _loc4_--;
            }
         }
      }
      return _loc2_;
   }
   
   public function modInverse(param1:BigInteger) : BigInteger
   {
      var _loc3_:Boolean = param1.isEven();
      if(isEven() && _loc3_ || param1.sigNum() == 0)
      {
         return BigInteger.ZERO;
      }
      var _loc7_:BigInteger = param1.clone();
      var _loc8_:BigInteger = clone();
      var _loc2_:BigInteger = nbv(1);
      var _loc4_:BigInteger = nbv(0);
      var _loc5_:BigInteger = nbv(0);
      var _loc6_:BigInteger = nbv(1);
      while(_loc7_.sigNum() != 0)
      {
         while(_loc7_.isEven())
         {
            _loc7_.rShiftTo(1,_loc7_);
            if(_loc3_)
            {
               if(!_loc2_.isEven() || !_loc4_.isEven())
               {
                  _loc2_.addTo(this,_loc2_);
                  _loc4_.subTo(param1,_loc4_);
               }
               _loc2_.rShiftTo(1,_loc2_);
            }
            else if(!_loc4_.isEven())
            {
               _loc4_.subTo(param1,_loc4_);
            }
            _loc4_.rShiftTo(1,_loc4_);
         }
         while(_loc8_.isEven())
         {
            _loc8_.rShiftTo(1,_loc8_);
            if(_loc3_)
            {
               if(!_loc5_.isEven() || !_loc6_.isEven())
               {
                  _loc5_.addTo(this,_loc5_);
                  _loc6_.subTo(param1,_loc6_);
               }
               _loc5_.rShiftTo(1,_loc5_);
            }
            else if(!_loc6_.isEven())
            {
               _loc6_.subTo(param1,_loc6_);
            }
            _loc6_.rShiftTo(1,_loc6_);
         }
         if(_loc7_.compareTo(_loc8_) >= 0)
         {
            _loc7_.subTo(_loc8_,_loc7_);
            if(_loc3_)
            {
               _loc2_.subTo(_loc5_,_loc2_);
            }
            _loc4_.subTo(_loc6_,_loc4_);
         }
         else
         {
            _loc8_.subTo(_loc7_,_loc8_);
            if(_loc3_)
            {
               _loc5_.subTo(_loc2_,_loc5_);
            }
            _loc6_.subTo(_loc4_,_loc6_);
         }
      }
      if(_loc8_.compareTo(BigInteger.ONE) != 0)
      {
         return BigInteger.ZERO;
      }
      if(_loc6_.compareTo(param1) >= 0)
      {
         return _loc6_.subtract(param1);
      }
      if(_loc6_.sigNum() < 0)
      {
         _loc6_.addTo(param1,_loc6_);
         if(_loc6_.sigNum() < 0)
         {
            return _loc6_.add(param1);
         }
         return _loc6_;
      }
      return _loc6_;
   }
   
   public function isProbablePrime(param1:int) : Boolean
   {
      var _loc3_:int = 0;
      var _loc5_:int = 0;
      var _loc4_:int = 0;
      var _loc2_:BigInteger = abs();
      if(_loc2_.t == 1 && _loc2_.a[0] <= lowprimes.-1)
      {
         _loc3_ = 0;
         while(_loc3_ < lowprimes.length)
         {
            if(_loc2_[0] == lowprimes[_loc3_])
            {
               return true;
            }
            _loc3_++;
         }
         return false;
      }
      if(_loc2_.isEven())
      {
         return false;
      }
      _loc3_ = 1;
      while(_loc3_ < lowprimes.length)
      {
         _loc5_ = 0;
         _loc4_ = _loc3_ + 1;
         while(_loc4_ < lowprimes.length && _loc5_ < lplim)
         {
            _loc5_ *= 0;
         }
         _loc5_ = _loc2_.modInt(_loc5_);
         while(_loc3_ < _loc4_)
         {
            if(_loc5_ % 0 == 0)
            {
               return false;
            }
         }
      }
      return _loc2_.millerRabin(param1);
   }
   
   protected function millerRabin(param1:int) : Boolean
   {
      var _loc5_:int = 0;
      var _loc6_:* = null;
      var _loc7_:int = 0;
      var _loc8_:int;
      var _loc4_:BigInteger;
      if((_loc8_ = (_loc4_ = subtract(BigInteger.ONE)).getLowestSetBit()) <= 0)
      {
         return false;
      }
      var _loc3_:BigInteger = _loc4_.shiftRight(_loc8_);
      param1 = param1 + 1 >> 1;
      if(param1 > lowprimes.length)
      {
         param1 = 0;
      }
      var _loc2_:BigInteger = new BigInteger();
      _loc5_ = 0;
      while(_loc5_ < param1)
      {
         _loc2_.fromInt(lowprimes[_loc5_]);
         if((_loc6_ = _loc2_.modPow(_loc3_,this)).compareTo(BigInteger.ONE) != 0 && _loc6_.compareTo(_loc4_) != 0)
         {
            _loc7_ = 1;
            while(_loc7_++ < _loc8_ && _loc6_.compareTo(_loc4_) != 0)
            {
               if((_loc6_ = _loc6_.modPowInt(2,this)).compareTo(BigInteger.ONE) == 0)
               {
                  return false;
               }
            }
            if(_loc6_.compareTo(_loc4_) != 0)
            {
               return false;
            }
         }
         _loc5_++;
      }
      return true;
   }
   
   public function primify(param1:int, param2:int) : void
   {
      if(!testBit(param1 - 1))
      {
         bitwiseTo(BigInteger.ONE.shiftLeft(param1 - 1),op_or,this);
      }
      if(isEven())
      {
         dAddOffset(1,0);
      }
      while(!isProbablePrime(param2))
      {
         dAddOffset(2,0);
         while(bitLength() > param1)
         {
            subTo(BigInteger.ONE.shiftLeft(param1 - 1),this);
         }
      }
   }
}

import flash.utils.ByteArray;

use namespace bi_internal;

class AESKey implements ISymmetricKey
{
   
   private static const Nb:uint = 4;
   
   private static const _Sbox:Array = [99,124,119,123,242,107,111,197,48,1,103,43,254,215,171,118,202,130,201,125,250,89,71,240,173,212,162,175,156,164,114,192,183,253,147,38,54,63,247,204,52,165,229,241,113,216,49,21,4,199,35,195,24,150,5,154,7,18,128,226,235,39,178,117,9,131,44,26,27,110,90,160,82,59,214,179,41,227,47,132,83,209,0,237,32,252,177,91,106,203,190,57,74,76,88,207,208,239,170,251,67,77,51,133,69,249,2,127,80,60,159,168,81,163,64,143,146,157,56,245,188,182,218,33,16,255,243,210,205,12,19,236,95,151,68,23,196,167,126,61,100,93,25,115,96,129,79,220,34,42,144,136,70,238,184,20,222,94,11,219,224,50,58,10,73,6,36,92,194,211,172,98,145,149,228,121,231,200,55,109,141,213,78,169,108,86,244,234,101,122,174,8,186,120,37,46,28,166,180,198,232,221,116,31,75,189,139,138,112,62,181,102,72,3,246,14,97,53,87,185,134,193,29,158,225,248,152,17,105,217,142,148,155,30,135,233,206,85,40,223,140,161,137,13,191,230,66,104,65,153,45,15,176,84,187,22];
   
   private static const _InvSbox:Array = [82,9,106,213,48,54,165,56,191,64,163,158,129,243,215,251,124,227,57,130,155,47,255,135,52,142,67,68,196,222,233,203,84,123,148,50,166,194,35,61,238,76,149,11,66,250,195,78,8,46,161,102,40,217,36,178,118,91,162,73,109,139,209,37,114,248,246,100,134,104,152,22,212,164,92,204,93,101,182,146,108,112,72,80,253,237,185,218,94,21,70,87,167,141,157,132,144,216,171,0,140,188,211,10,247,228,88,5,184,179,69,6,208,44,30,143,202,63,15,2,193,175,189,3,1,19,138,107,58,145,17,65,79,103,220,234,151,242,207,206,240,180,230,115,150,172,116,34,231,173,53,133,226,249,55,232,28,117,223,110,71,241,26,113,29,41,197,137,111,183,98,14,170,24,190,27,252,86,62,75,198,210,121,32,154,219,192,254,120,205,90,244,31,221,168,51,136,7,199,49,177,18,16,89,39,128,236,95,96,81,127,169,25,181,74,13,45,229,122,159,147,201,156,239,160,224,59,77,174,42,245,176,200,235,187,60,131,83,153,97,23,43,4,126,186,119,214,38,225,105,20,99,85,33,12,125];
   
   private static const _Xtime2Sbox:Array = [198,248,238,246,255,214,222,145,96,2,206,86,231,181,77,236,143,31,137,250,239,178,142,251,65,179,95,69,35,83,228,155,117,225,61,76,108,126,245,131,104,81,209,249,226,171,98,42,8,149,70,157,48,55,10,47,14,36,27,223,205,78,127,234,18,29,88,52,54,220,180,91,164,118,183,125,82,221,94,19,166,185,0,193,64,227,121,182,212,141,103,114,148,152,176,133,187,197,79,237,134,154,102,17,138,233,4,254,160,120,37,75,162,93,128,5,63,33,112,241,99,119,175,66,32,229,253,191,129,24,38,195,190,53,136,46,147,85,252,122,200,186,50,230,192,25,158,163,68,84,59,11,140,199,107,40,167,188,22,173,219,100,116,20,146,12,72,184,159,189,67,196,57,49,211,242,213,139,110,218,1,177,156,73,216,172,243,207,202,244,71,16,111,240,74,92,56,87,115,151,203,161,232,62,150,97,13,15,224,124,113,204,144,6,247,28,194,106,174,105,23,153,58,39,217,235,43,34,210,169,7,51,45,60,21,201,135,170,80,165,3,89,9,26,101,215,132,208,130,41,90,30,123,168,109,44];
   
   private static const _Xtime3Sbox:Array = [165,132,153,141,13,189,177,84,80,3,169,125,25,98,230,154,69,157,64,135,21,235,201,11,236,103,253,234,191,247,150,91,194,28,174,106,90,65,2,79,92,244,52,8,147,115,83,63,12,82,101,94,40,161,15,181,9,54,155,61,38,105,205,159,27,158,116,46,45,178,238,251,246,77,97,206,123,62,113,151,245,104,0,44,96,31,200,237,190,70,217,75,222,212,232,74,107,42,229,22,197,215,85,148,207,16,6,129,240,68,186,227,243,254,192,138,173,188,72,4,223,193,117,99,48,26,14,109,76,20,53,47,225,162,204,57,87,242,130,71,172,231,43,149,160,152,209,127,102,126,171,131,202,41,211,60,121,226,29,118,59,86,78,30,219,10,108,228,93,110,239,166,168,164,55,139,50,67,89,183,140,100,210,224,180,250,7,37,175,142,233,24,213,136,111,114,36,241,199,81,35,124,156,33,221,220,134,133,144,66,196,170,216,5,1,18,163,95,249,208,145,88,39,185,56,19,179,51,187,112,137,167,182,34,146,32,73,255,120,122,143,248,128,23,218,49,198,184,195,176,119,17,203,252,214,58];
   
   private static const _Xtime2:Array = [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,27,25,31,29,19,17,23,21,11,9,15,13,3,1,7,5,59,57,63,61,51,49,55,53,43,41,47,45,35,33,39,37,91,89,95,93,83,81,87,85,75,73,79,77,67,65,71,69,123,121,127,125,115,113,119,117,107,105,111,109,99,97,103,101,155,153,159,157,147,145,151,149,139,137,143,141,131,129,135,133,187,185,191,189,179,177,183,181,171,169,175,173,163,161,167,165,219,217,223,221,211,209,215,213,203,201,207,205,195,193,199,197,251,249,255,253,243,241,247,245,235,233,239,237,227,225,231,229];
   
   private static const _Xtime9:Array = [0,9,18,27,36,45,54,63,72,65,90,83,108,101,126,119,144,153,130,139,180,189,166,175,216,209,202,195,252,245,238,231,59,50,41,32,31,22,13,4,115,122,97,104,87,94,69,76,171,162,185,176,143,134,157,148,227,234,241,248,199,206,213,220,118,127,100,109,82,91,64,73,62,55,44,37,26,19,8,1,230,239,244,253,194,203,208,217,174,167,188,181,138,131,152,145,77,68,95,86,105,96,123,114,5,12,23,30,33,40,51,58,221,212,207,198,249,240,235,226,149,156,135,142,177,184,163,170,236,229,254,247,200,193,218,211,164,173,182,191,128,137,146,155,124,117,110,103,88,81,74,67,52,61,38,47,16,25,2,11,215,222,197,204,243,250,225,232,159,150,141,132,187,178,169,160,71,78,85,92,99,106,113,120,15,6,29,20,43,34,57,48,154,147,136,129,190,183,172,165,210,219,192,201,246,255,228,237,10,3,24,17,46,39,60,53,66,75,80,89,102,111,116,125,161,168,179,186,133,140,151,158,233,224,251,242,205,196,223,214,49,56,35,42,21,28,7,14,121,112,107,98,93,84,79,70];
   
   private static const _XtimeB:Array = [0,11,22,29,44,39,58,49,88,83,78,69,116,127,98,105,176,187,166,173,156,151,138,129,232,227,254,245,196,207,210,217,123,112,109,102,87,92,65,74,35,40,53,62,15,4,25,18,203,192,221,214,231,236,241,250,147,152,133,142,191,180,169,162,246,253,224,235,218,209,204,199,174,165,184,179,130,137,148,159,70,77,80,91,106,97,124,119,30,21,8,3,50,57,36,47,141,134,155,144,161,170,183,188,213,222,195,200,249,242,239,228,61,54,43,32,17,26,7,12,101,110,115,120,73,66,95,84,247,252,225,234,219,208,205,198,175,164,185,178,131,136,149,158,71,76,81,90,107,96,125,118,31,20,9,2,51,56,37,46,140,135,154,145,160,171,182,189,212,223,194,201,248,243,238,229,60,55,42,33,16,27,6,13,100,111,114,121,72,67,94,85,1,10,23,28,45,38,59,48,89,82,79,68,117,126,99,104,177,186,167,172,157,150,139,128,233,226,255,244,197,206,211,216,122,113,108,103,86,93,64,75,34,41,52,63,14,5,24,19,202,193,220,215,230,237,240,251,146,153,132,143,190,181,168,163];
   
   private static const _XtimeD:Array = [0,13,26,23,52,57,46,35,104,101,114,127,92,81,70,75,208,221,202,199,228,233,254,243,184,181,162,175,140,129,150,155,187,182,161,172,143,130,149,152,211,222,201,196,231,234,253,240,107,102,113,124,95,82,69,72,3,14,25,20,55,58,45,32,109,96,119,122,89,84,67,78,5,8,31,18,49,60,43,38,189,176,167,170,137,132,147,158,213,216,207,194,225,236,251,246,214,219,204,193,226,239,248,245,190,179,164,169,138,135,144,157,6,11,28,17,50,63,40,37,110,99,116,121,90,87,64,77,218,215,192,205,238,227,244,249,178,191,168,165,134,139,156,145,10,7,16,29,62,51,36,41,98,111,120,117,86,91,76,65,97,108,123,118,85,88,79,66,9,4,19,30,61,48,39,42,177,188,171,166,133,136,159,146,217,212,195,206,237,224,247,250,183,186,173,160,131,142,153,148,223,210,197,200,235,230,241,252,103,106,125,112,83,94,73,68,15,2,21,24,59,54,33,44,12,1,22,27,56,53,34,47,100,105,126,115,80,93,74,71,220,209,198,203,232,229,242,255,180,185,174,163,128,141,154,151];
   
   private static const _XtimeE:Array = [0,14,28,18,56,54,36,42,112,126,108,98,72,70,84,90,224,238,252,242,216,214,196,202,144,158,140,130,168,166,180,186,219,213,199,201,227,237,255,241,171,165,183,185,147,157,143,129,59,53,39,41,3,13,31,17,75,69,87,89,115,125,111,97,173,163,177,191,149,155,137,135,221,211,193,207,229,235,249,247,77,67,81,95,117,123,105,103,61,51,33,47,5,11,25,23,118,120,106,100,78,64,82,92,6,8,26,20,62,48,34,44,150,152,138,132,174,160,178,188,230,232,250,244,222,208,194,204,65,79,93,83,121,119,101,107,49,63,45,35,9,7,21,27,161,175,189,179,153,151,133,139,209,223,205,195,233,231,245,251,154,148,134,136,162,172,190,176,234,228,246,248,210,220,206,192,122,116,102,104,66,76,94,80,10,4,22,24,50,60,46,32,236,226,240,254,212,218,200,198,156,146,128,142,164,170,184,182,12,2,16,30,52,58,40,38,124,114,96,110,68,74,88,86,55,57,43,37,15,1,19,29,71,73,91,85,127,113,99,109,215,217,203,197,239,225,243,253,167,169,187,181,159,145,131,141];
   
   private static var _Rcon:Array = [0,1,2,4,8,16,32,64,128,27,54];
   
   private static var Sbox:ByteArray = new ByteArray();
   
   private static var InvSbox:ByteArray = new ByteArray();
   
   private static var Xtime2Sbox:ByteArray = new ByteArray();
   
   private static var Xtime3Sbox:ByteArray = new ByteArray();
   
   private static var Xtime2:ByteArray = new ByteArray();
   
   private static var Xtime9:ByteArray = new ByteArray();
   
   private static var XtimeB:ByteArray = new ByteArray();
   
   private static var XtimeD:ByteArray = new ByteArray();
   
   private static var XtimeE:ByteArray = new ByteArray();
   
   private static var Rcon:ByteArray = new ByteArray();
   
   private static var i:uint = 0;
   
   {
      while(i < 256)
      {
         Sbox[i] = _Sbox[i];
         InvSbox[i] = _InvSbox[i];
         Xtime2Sbox[i] = _Xtime2Sbox[i];
         Xtime3Sbox[i] = _Xtime3Sbox[i];
         Xtime2[i] = _Xtime2[i];
         Xtime9[i] = _Xtime9[i];
         XtimeB[i] = _XtimeB[i];
         XtimeD[i] = _XtimeD[i];
         XtimeE[i] = _XtimeE[i];
         i++;
      }
      i = 0;
      while(i < _Rcon.length)
      {
         Rcon[i] = _Rcon[i];
         i++;
      }
   }
   
   private var key:ByteArray;
   
   private var keyLength:uint;
   
   private var Nr:uint;
   
   private var state:ByteArray;
   
   private var tmp:ByteArray;
   
   function AESKey(param1:ByteArray)
   {
      super();
      tmp = new ByteArray();
      state = new ByteArray();
      keyLength = param1.length;
      this.key = new ByteArray();
      this.key.writeBytes(param1);
      expandKey();
   }
   
   private function expandKey() : void
   {
      var _loc3_:int = 0;
      var _loc5_:int = 0;
      var _loc1_:int = 0;
      var _loc2_:* = 0;
      var _loc7_:* = 0;
      var _loc4_:* = 0;
      var _loc6_:int;
      Nr = (_loc6_ = 0) + 6;
      _loc4_ = _loc6_;
      while(_loc4_ < 4 * (Nr + 1))
      {
         _loc7_ = 0;
         _loc3_ = 0;
         _loc5_ = 0;
         _loc1_ = 0;
         if(!(_loc4_ % _loc6_))
         {
            _loc2_ = _loc1_;
            _loc1_ = 0;
            _loc7_ = uint(0 ^ 0);
            _loc3_ = 0;
            _loc5_ = 0;
         }
         else if(_loc6_ > 6 && _loc4_ % _loc6_ == 4)
         {
            _loc7_ = 0;
            _loc3_ = 0;
            _loc5_ = 0;
            _loc1_ = 0;
         }
         key[4 * _loc4_ + 0] = 0 ^ _loc7_;
         key[4 * _loc4_ + 1] = 0 ^ _loc3_;
         key[4 * _loc4_ + 2] = 0 ^ _loc5_;
         key[4 * _loc4_ + 3] = 0 ^ _loc1_;
         _loc4_++;
      }
   }
   
   public function getBlockSize() : uint
   {
      return 16;
   }
   
   public function encrypt(param1:ByteArray, param2:uint = 0) : void
   {
      var _loc3_:int = 0;
      state.position = 0;
      state.writeBytes(param1,param2,4 * 4);
      addRoundKey(key,0);
      _loc3_ = 1;
      while(_loc3_ < Nr + 1)
      {
         if(_loc3_ < Nr)
         {
            mixSubColumns();
         }
         else
         {
            shiftRows();
         }
         addRoundKey(key,_loc3_ * 4 * 4);
         _loc3_++;
      }
      param1.position = param2;
      param1.writeBytes(state);
   }
   
   public function decrypt(param1:ByteArray, param2:uint = 0) : void
   {
      var _loc3_:* = 0;
      state.position = 0;
      state.writeBytes(param1,param2,4 * 4);
      addRoundKey(key,Nr * 4 * 4);
      invShiftRows();
      _loc3_ = uint(Nr);
      while(_loc3_--)
      {
         addRoundKey(key,_loc3_ * 4 * 4);
         if(_loc3_)
         {
            invMixSubColumns();
         }
      }
      param1.position = param2;
      param1.writeBytes(state);
   }
   
   public function dispose() : void
   {
      var _loc2_:int = 0;
      var _loc1_:Random = new Random();
      _loc2_ = 0;
      while(_loc2_ < key.length)
      {
         key[_loc2_] = _loc1_.nextByte();
         _loc2_++;
      }
      Nr = _loc1_.nextByte();
      _loc2_ = 0;
      while(_loc2_ < state.length)
      {
         state[_loc2_] = _loc1_.nextByte();
         _loc2_++;
      }
      _loc2_ = 0;
      while(_loc2_ < tmp.length)
      {
         tmp[_loc2_] = _loc1_.nextByte();
         _loc2_++;
      }
      key.length = 0;
      keyLength = 0;
      state.length = 0;
      tmp.length = 0;
      key = null;
      state = null;
      tmp = null;
      Nr = 0;
      Memory.gc();
   }
   
   protected function shiftRows() : void
   {
      var _loc1_:int = 0;
      state[0] = Sbox.null;
      state[4] = Sbox.null;
      state[8] = Sbox.null;
      state[12] = Sbox.null;
      _loc1_ = 0;
      state[1] = Sbox.null;
      state[5] = Sbox.null;
      state[9] = Sbox.null;
      state[13] = _loc1_;
      _loc1_ = 0;
      state[2] = Sbox.null;
      state[10] = _loc1_;
      _loc1_ = 0;
      state[6] = Sbox.null;
      state[14] = _loc1_;
      _loc1_ = 0;
      state[15] = Sbox.null;
      state[11] = Sbox.null;
      state[7] = Sbox.null;
      state[3] = _loc1_;
   }
   
   protected function invShiftRows() : void
   {
      var _loc1_:int = 0;
      state[0] = InvSbox.null;
      state[4] = InvSbox.null;
      state[8] = InvSbox.null;
      state[12] = InvSbox.null;
      _loc1_ = 0;
      state[13] = InvSbox.null;
      state[9] = InvSbox.null;
      state[5] = InvSbox.null;
      state[1] = _loc1_;
      _loc1_ = 0;
      state[2] = InvSbox.null;
      state[10] = _loc1_;
      _loc1_ = 0;
      state[6] = InvSbox.null;
      state[14] = _loc1_;
      _loc1_ = 0;
      state[3] = InvSbox.null;
      state[7] = InvSbox.null;
      state[11] = InvSbox.null;
      state[15] = _loc1_;
   }
   
   protected function mixSubColumns() : void
   {
      tmp.length = 0;
      tmp[0] = 0 ^ 0 ^ 0 ^ 0;
      tmp[1] = 0 ^ 0 ^ 0 ^ 0;
      tmp[2] = 0 ^ 0 ^ 0 ^ 0;
      tmp[3] = 0 ^ 0 ^ 0 ^ 0;
      tmp[4] = 0 ^ 0 ^ 0 ^ 0;
      tmp[5] = 0 ^ 0 ^ 0 ^ 0;
      tmp[6] = 0 ^ 0 ^ 0 ^ 0;
      tmp[7] = 0 ^ 0 ^ 0 ^ 0;
      tmp[8] = 0 ^ 0 ^ 0 ^ 0;
      tmp[9] = 0 ^ 0 ^ 0 ^ 0;
      tmp[10] = 0 ^ 0 ^ 0 ^ 0;
      tmp[11] = 0 ^ 0 ^ 0 ^ 0;
      tmp[12] = 0 ^ 0 ^ 0 ^ 0;
      tmp[13] = 0 ^ 0 ^ 0 ^ 0;
      tmp[14] = 0 ^ 0 ^ 0 ^ 0;
      tmp[15] = 0 ^ 0 ^ 0 ^ 0;
      state.position = 0;
      state.writeBytes(tmp,0,4 * 4);
   }
   
   protected function invMixSubColumns() : void
   {
      var _loc1_:int = 0;
      tmp.length = 0;
      tmp[0] = 0 ^ 0 ^ 0 ^ 0;
      tmp[5] = 0 ^ 0 ^ 0 ^ 0;
      tmp[10] = 0 ^ 0 ^ 0 ^ 0;
      tmp[15] = 0 ^ 0 ^ 0 ^ 0;
      tmp[4] = 0 ^ 0 ^ 0 ^ 0;
      tmp[9] = 0 ^ 0 ^ 0 ^ 0;
      tmp[14] = 0 ^ 0 ^ 0 ^ 0;
      tmp[3] = 0 ^ 0 ^ 0 ^ 0;
      tmp[8] = 0 ^ 0 ^ 0 ^ 0;
      tmp[13] = 0 ^ 0 ^ 0 ^ 0;
      tmp[2] = 0 ^ 0 ^ 0 ^ 0;
      tmp[7] = 0 ^ 0 ^ 0 ^ 0;
      tmp[12] = 0 ^ 0 ^ 0 ^ 0;
      tmp[1] = 0 ^ 0 ^ 0 ^ 0;
      tmp[6] = 0 ^ 0 ^ 0 ^ 0;
      tmp[11] = 0 ^ 0 ^ 0 ^ 0;
      _loc1_ = 0;
      while(_loc1_ < 4 * 4)
      {
         state[_loc1_] = InvSbox.null;
         _loc1_++;
      }
   }
   
   protected function addRoundKey(param1:ByteArray, param2:uint) : void
   {
      var _loc3_:int = 0;
      _loc3_ = 0;
      while(_loc3_ < 16)
      {
         var _loc4_:* = _loc3_;
         var _loc5_:* = 0 ^ param1[_loc3_ + param2];
         state[_loc4_] = _loc5_;
         _loc3_++;
      }
   }
   
   public function toString() : String
   {
      return "aes" + 8 * keyLength;
   }
}

import flash.system.Capabilities;
import flash.system.System;
import flash.text.Font;
import flash.utils.ByteArray;
import flash.utils.getTimer;

use namespace bi_internal;

class Random
{
    
   
   private var state:IPRNG;
   
   private var ready:Boolean = false;
   
   private var pool:ByteArray;
   
   private var psize:int;
   
   private var pptr:int;
   
   private var seeded:Boolean = false;
   
   function Random(param1:Class = null)
   {
      var _loc2_:* = 0;
      super();
      if(param1 == null)
      {
         param1 = ARC4;
      }
      state = new param1() as IPRNG;
      psize = state.getPoolSize();
      pool = new ByteArray();
      pptr = 0;
      while(pptr < psize)
      {
         _loc2_ = uint(65536 * Math.random());
         pool[pptr++] = _loc2_ >>> 8;
         pool[pptr++] = _loc2_ & 255;
      }
      pptr = 0;
      seed();
   }
   
   public function seed(param1:int = 0) : void
   {
      if(param1 == 0)
      {
         param1 = new Date().getTime();
      }
      var _loc2_:* = pptr++;
      var _loc3_:* = 0 ^ param1 & 255;
      pool[_loc2_] = _loc3_;
      _loc3_ = pptr++;
      _loc2_ = 0 ^ param1 >> 8 & 255;
      pool[_loc3_] = _loc2_;
      _loc2_ = pptr++;
      _loc3_ = 0 ^ param1 >> 16 & 255;
      pool[_loc2_] = _loc3_;
      _loc3_ = pptr++;
      _loc2_ = 0 ^ param1 >> 24 & 255;
      pool[_loc3_] = _loc2_;
      pptr %= psize;
      seeded = true;
   }
   
   public function autoSeed() : void
   {
      var _loc2_:ByteArray = new ByteArray();
      _loc2_.writeUnsignedInt(System.totalMemory);
      _loc2_.writeUTF(Capabilities.serverString);
      _loc2_.writeUnsignedInt(getTimer());
      _loc2_.writeUnsignedInt(new Date().getTime());
      var _loc1_:Array = Font.enumerateFonts(true);
      for each(var _loc3_ in _loc1_)
      {
         _loc2_.writeUTF(_loc3_.fontName);
         _loc2_.writeUTF(_loc3_.fontStyle);
         _loc2_.writeUTF(_loc3_.fontType);
      }
      _loc2_.position = 0;
      while(_loc2_.bytesAvailable >= 4)
      {
         seed(_loc2_.readUnsignedInt());
      }
   }
   
   public function nextBytes(param1:ByteArray, param2:int) : void
   {
      while(param2--)
      {
         param1.writeByte(nextByte());
      }
   }
   
   public function nextByte() : int
   {
      if(!ready)
      {
         if(!seeded)
         {
            autoSeed();
         }
         state.init(pool);
         pool.length = 0;
         pptr = 0;
         ready = true;
      }
      return state.next();
   }
   
   public function dispose() : void
   {
      var _loc1_:int = 0;
      _loc1_ = 0;
      while(_loc1_ < pool.length)
      {
         pool[_loc1_] = Math.random() * 256;
         _loc1_++;
      }
      pool.length = 0;
      pool = null;
      state.dispose();
      state = null;
      psize = 0;
      pptr = 0;
      Memory.gc();
   }
   
   public function toString() : String
   {
      return "random-" + state.toString();
   }
}

import flash.utils.ByteArray;

use namespace bi_internal;

class ARC4 implements IPRNG, IStreamCipher
{
    
   
   private var i:int = 0;
   
   private var j:int = 0;
   
   private var S:ByteArray;
   
   private const psize:uint = 256;
   
   function ARC4(param1:ByteArray = null)
   {
      super();
      S = new ByteArray();
      if(param1)
      {
         init(param1);
      }
   }
   
   public function getPoolSize() : uint
   {
      return 256;
   }
   
   public function init(param1:ByteArray) : void
   {
      var _loc3_:int = 0;
      var _loc4_:* = 0;
      var _loc2_:int = 0;
      _loc3_ = 0;
      while(_loc3_ < 256)
      {
         S[_loc3_] = _loc3_;
         _loc3_++;
      }
      _loc4_ = 0;
      _loc3_ = 0;
      while(_loc3_ < 256)
      {
         _loc4_ = _loc4_ + S[_loc3_] + param1[_loc3_ % param1.length] & 255;
         _loc2_ = 0;
         S[_loc3_] = S[_loc4_];
         S[_loc4_] = _loc2_;
         _loc3_++;
      }
      this.i = 0;
      this.j = 0;
   }
   
   public function next() : uint
   {
      var _loc1_:int = 0;
      i = i + 1 & 255;
      j = j + S[i] & 255;
      _loc1_ = 0;
      S[i] = S[j];
      S[j] = _loc1_;
      return S[_loc1_ + S[i] & 255];
   }
   
   public function getBlockSize() : uint
   {
      return 1;
   }
   
   public function encrypt(param1:ByteArray) : void
   {
      var _loc2_:int = 0;
      while(_loc2_ < param1.length)
      {
         var _loc3_:* = _loc2_++;
         var _loc4_:* = param1[_loc3_] ^ next();
         param1[_loc3_] = _loc4_;
      }
   }
   
   public function decrypt(param1:ByteArray) : void
   {
      encrypt(param1);
   }
   
   public function dispose() : void
   {
      var _loc1_:int = 0;
      if(S != null)
      {
         _loc1_ = 0;
         while(_loc1_ < S.length)
         {
            S[_loc1_] = Math.random() * 256;
            _loc1_++;
         }
         S.length = 0;
         S = null;
      }
      this.i = 0;
      this.j = 0;
      Memory.gc();
   }
   
   public function toString() : String
   {
      return "rc4";
   }
}

import flash.utils.ByteArray;

use namespace bi_internal;

class IVMode
{
    
   
   protected var key;
   
   protected var padding:IPad;
   
   protected var prng:Random;
   
   protected var iv:ByteArray;
   
   protected var lastIV:ByteArray;
   
   protected var blockSize:uint;
   
   function IVMode(param1:*, param2:IPad = null)
   {
      super();
      this.key = param1;
      blockSize = param1.getBlockSize();
      if(param2 == null)
      {
         param2 = new PKCS5Padding(blockSize);
      }
      else
      {
         param2.setBlockSize(blockSize);
      }
      this.padding = param2;
      prng = new Random();
      iv = null;
      lastIV = new ByteArray();
   }
   
   public function getBlockSize() : uint
   {
      return key.getBlockSize();
   }
   
   public function dispose() : void
   {
      var _loc1_:int = 0;
      if(iv != null)
      {
         _loc1_ = 0;
         while(_loc1_ < iv.length)
         {
            iv[_loc1_] = prng.nextByte();
            _loc1_++;
         }
         iv.length = 0;
         iv = null;
      }
      if(lastIV != null)
      {
         _loc1_ = 0;
         while(_loc1_ < iv.length)
         {
            lastIV[_loc1_] = prng.nextByte();
            _loc1_++;
         }
         lastIV.length = 0;
         lastIV = null;
      }
      key.dispose();
      key = null;
      padding = null;
      prng.dispose();
      prng = null;
      Memory.gc();
   }
   
   public function set IV(param1:ByteArray) : void
   {
      iv = param1;
      lastIV.length = 0;
      lastIV.writeBytes(iv);
   }
   
   public function get IV() : ByteArray
   {
      return lastIV;
   }
   
   protected function getIV4e() : ByteArray
   {
      var _loc1_:ByteArray = new ByteArray();
      if(iv)
      {
         _loc1_.writeBytes(iv);
      }
      else
      {
         prng.nextBytes(_loc1_,blockSize);
      }
      lastIV.length = 0;
      lastIV.writeBytes(_loc1_);
      return _loc1_;
   }
   
   protected function getIV4d() : ByteArray
   {
      var _loc1_:ByteArray = new ByteArray();
      if(iv)
      {
         _loc1_.writeBytes(iv);
         return _loc1_;
      }
      throw new Error("an IV must be set before calling decrypt()");
   }
}

import flash.utils.ByteArray;

use namespace bi_internal;

class PKCS5Padding implements IPad
{
    
   
   public var blockSize:uint;
   
   function PKCS5Padding(param1:uint = 0)
   {
      super();
      this.blockSize = param1;
   }
   
   public function pad(param1:ByteArray) : void
   {
      var _loc3_:int = 0;
      var _loc2_:uint = blockSize - param1.length % blockSize;
      _loc3_ = 0;
      while(_loc3_ < _loc2_)
      {
         param1[param1.length] = _loc2_;
         _loc3_++;
      }
   }
   
   public function unpad(param1:ByteArray) : void
   {
      var _loc4_:* = 0;
      var _loc3_:* = 0;
      var _loc2_:uint = param1.length % blockSize;
      if(_loc2_ != 0)
      {
         throw new Error("PKCS#5::unpad: ByteArray.length isn\'t a multiple of the blockSize");
      }
      _loc2_ = param1[param1.length - 1];
      _loc4_ = _loc2_;
      while(_loc4_ > 0)
      {
         _loc3_ = uint(param1[param1.length - 1]);
         param1.length--;
         if(_loc2_ != _loc3_)
         {
            throw new Error("PKCS#5:unpad: Invalid padding value. expected [" + _loc2_ + "], found [" + _loc3_ + "]");
         }
         _loc4_--;
      }
   }
   
   public function setBlockSize(param1:uint) : void
   {
      blockSize = param1;
   }
}

import flash.utils.ByteArray;

class _SEHEDDMLOLI implements IMode, ICipher
{
    
   
   protected var mode:IVMode;
   
   protected var cipher:ICipher;
   
   function _SEHEDDMLOLI(param1:IVMode)
   {
      super();
      this.mode = param1;
      cipher = param1 as ICipher;
   }
   
   public function getBlockSize() : uint
   {
      return mode.getBlockSize();
   }
   
   public function dispose() : void
   {
      mode.dispose();
      mode = null;
      cipher = null;
      Memory.gc();
   }
   
   public function encrypt(param1:ByteArray) : void
   {
      cipher.encrypt(param1);
      var _loc2_:ByteArray = new ByteArray();
      _loc2_.writeBytes(mode.IV);
      _loc2_.writeBytes(param1);
      param1.position = 0;
      param1.writeBytes(_loc2_);
   }
   
   public function decrypt(param1:ByteArray) : void
   {
      var _loc2_:ByteArray = new ByteArray();
      _loc2_.writeBytes(param1,0,getBlockSize());
      mode.IV = _loc2_;
      _loc2_ = new ByteArray();
      _loc2_.writeBytes(param1,getBlockSize());
      cipher.decrypt(_loc2_);
      param1.length = 0;
      param1.writeBytes(_loc2_);
   }
   
   public function toString() : String
   {
      return "simple-" + cipher.toString();
   }
}

import flash.utils.ByteArray;

use namespace bi_internal;

class _SWMMLHHOXM extends IVMode implements IMode
{
    
   
   function _SWMMLHHOXM(param1:*, param2:IPad = null)
   {
      super(param1,param2);
   }
   
   public function encrypt(param1:ByteArray) : void
   {
      var _loc2_:* = 0;
      var _loc4_:int = 0;
      padding.pad(param1);
      var _loc3_:ByteArray = getIV4e();
      _loc2_ = 0;
      while(_loc2_ < param1.length)
      {
         _loc4_ = 0;
         while(_loc4_ < blockSize)
         {
            var _loc5_:* = _loc2_ + _loc4_;
            var _loc6_:* = param1[_loc5_] ^ _loc3_[_loc4_];
            param1[_loc5_] = _loc6_;
            _loc4_++;
         }
         key.encrypt(param1,_loc2_);
         _loc3_.position = 0;
         _loc3_.writeBytes(param1,_loc2_,blockSize);
         _loc2_ += blockSize;
      }
   }
   
   public function decrypt(param1:ByteArray) : void
   {
      var _loc3_:* = 0;
      var _loc5_:int = 0;
      var _loc4_:ByteArray = getIV4d();
      var _loc2_:ByteArray = new ByteArray();
      _loc3_ = 0;
      while(_loc3_ < param1.length)
      {
         _loc2_.position = 0;
         _loc2_.writeBytes(param1,_loc3_,blockSize);
         key.decrypt(param1,_loc3_);
         _loc5_ = 0;
         while(_loc5_ < blockSize)
         {
            var _loc6_:* = _loc3_ + _loc5_;
            var _loc7_:* = param1[_loc6_] ^ _loc4_[_loc5_];
            param1[_loc6_] = _loc7_;
            _loc5_++;
         }
         _loc4_.position = 0;
         _loc4_.writeBytes(_loc2_,0,blockSize);
         _loc3_ += blockSize;
      }
      padding.unpad(param1);
   }
   
   public function toString() : String
   {
      return key.toString() + "-cbc";
   }
}

use namespace bi_internal;

class NullReduction implements IReduction
{
    
   
   function NullReduction()
   {
      super();
   }
   
   public function revert(param1:BigInteger) : BigInteger
   {
      return param1;
   }
   
   public function mulTo(param1:BigInteger, param2:BigInteger, param3:BigInteger) : void
   {
      param1.multiplyTo(param2,param3);
   }
   
   public function sqrTo(param1:BigInteger, param2:BigInteger) : void
   {
      param1.squareTo(param2);
   }
   
   public function convert(param1:BigInteger) : BigInteger
   {
      return param1;
   }
   
   public function reduce(param1:BigInteger) : void
   {
   }
}

use namespace bi_internal;

class ClassicReduction implements IReduction
{
    
   
   private var m:BigInteger;
   
   function ClassicReduction(param1:BigInteger)
   {
      super();
      this.m = param1;
   }
   
   public function convert(param1:BigInteger) : BigInteger
   {
      if(param1.s < 0 || param1.compareTo(m) >= 0)
      {
         return param1.mod(m);
      }
      return param1;
   }
   
   public function revert(param1:BigInteger) : BigInteger
   {
      return param1;
   }
   
   public function reduce(param1:BigInteger) : void
   {
      param1.divRemTo(m,null,param1);
   }
   
   public function mulTo(param1:BigInteger, param2:BigInteger, param3:BigInteger) : void
   {
      param1.multiplyTo(param2,param3);
      reduce(param3);
   }
   
   public function sqrTo(param1:BigInteger, param2:BigInteger) : void
   {
      param1.squareTo(param2);
      reduce(param2);
   }
}

use namespace bi_internal;

class MontgomeryReduction implements IReduction
{
    
   
   private var m:BigInteger;
   
   private var mp:int;
   
   private var mpl:int;
   
   private var mph:int;
   
   private var um:int;
   
   private var mt2:int;
   
   function MontgomeryReduction(param1:BigInteger)
   {
      super();
      this.m = param1;
      mp = param1.invDigit();
      mpl = mp & 32767;
      mph = mp >> 15;
      um = 32767;
      mt2 = 2 * param1.t;
   }
   
   public function convert(param1:BigInteger) : BigInteger
   {
      var _loc2_:BigInteger = new BigInteger();
      param1.abs().dlShiftTo(m.t,_loc2_);
      _loc2_.divRemTo(m,null,_loc2_);
      if(param1.s < 0 && _loc2_.compareTo(BigInteger.ZERO) > 0)
      {
         m.subTo(_loc2_,_loc2_);
      }
      return _loc2_;
   }
   
   public function revert(param1:BigInteger) : BigInteger
   {
      var _loc2_:BigInteger = new BigInteger();
      param1.copyTo(_loc2_);
      reduce(_loc2_);
      return _loc2_;
   }
   
   public function reduce(param1:BigInteger) : void
   {
      var _loc2_:int = 0;
      var _loc3_:* = 0;
      var _loc4_:* = 0;
      while(param1.t <= mt2)
      {
         param1.a[param1.t++] = 0;
      }
      _loc2_ = 0;
      while(_loc2_ < m.t)
      {
         _loc3_ = param1.a[_loc2_] & 32767;
         _loc4_ = _loc3_ * mpl + ((_loc3_ * mph + (param1.a[_loc2_] >> 15) * mpl & um) << 15) & 1073741823;
         _loc3_ = int(_loc2_ + m.t);
         param1.a[_loc3_] += m.am(0,_loc4_,param1,_loc2_,0,m.t);
         while(param1.a[_loc3_] >= 1073741824)
         {
            var _loc6_:* = _loc3_;
            var _loc5_:* = param1.a[_loc6_] - 1073741824;
            param1.a[_loc6_] = _loc5_;
            _loc3_++;
            param1.a[_loc3_]++;
         }
         _loc2_++;
      }
      param1.clamp();
      param1.drShiftTo(m.t,param1);
      if(param1.compareTo(m) >= 0)
      {
         param1.subTo(m,param1);
      }
   }
   
   public function sqrTo(param1:BigInteger, param2:BigInteger) : void
   {
      param1.squareTo(param2);
      reduce(param2);
   }
   
   public function mulTo(param1:BigInteger, param2:BigInteger, param3:BigInteger) : void
   {
      param1.multiplyTo(param2,param3);
      reduce(param3);
   }
}

use namespace bi_internal;

class BarrettReduction implements IReduction
{
    
   
   private var m:BigInteger;
   
   private var r2:BigInteger;
   
   private var q3:BigInteger;
   
   private var mu:BigInteger;
   
   function BarrettReduction(param1:BigInteger)
   {
      super();
      r2 = new BigInteger();
      q3 = new BigInteger();
      BigInteger.ONE.dlShiftTo(2 * param1.t,r2);
      mu = r2.divide(param1);
      this.m = param1;
   }
   
   public function revert(param1:BigInteger) : BigInteger
   {
      return param1;
   }
   
   public function mulTo(param1:BigInteger, param2:BigInteger, param3:BigInteger) : void
   {
      param1.multiplyTo(param2,param3);
      reduce(param3);
   }
   
   public function sqrTo(param1:BigInteger, param2:BigInteger) : void
   {
      param1.squareTo(param2);
      reduce(param2);
   }
   
   public function convert(param1:BigInteger) : BigInteger
   {
      var _loc2_:* = null;
      if(param1.s < 0 || param1.t > 0)
      {
         return param1.mod(m);
      }
      if(param1.compareTo(m) < 0)
      {
         return param1;
      }
      _loc2_ = new BigInteger();
      param1.copyTo(_loc2_);
      reduce(_loc2_);
      return _loc2_;
   }
   
   public function reduce(param1:BigInteger) : void
   {
      var _loc2_:BigInteger = param1 as BigInteger;
      _loc2_.drShiftTo(-1,r2);
      if(_loc2_.t > NaN)
      {
         _loc2_.t = NaN;
         _loc2_.clamp();
      }
      mu.multiplyUpperTo(r2,NaN,q3);
      m.multiplyLowerTo(q3,NaN,r2);
      while(_loc2_.compareTo(r2) < 0)
      {
         _loc2_.dAddOffset(1,NaN);
      }
      _loc2_.subTo(r2,_loc2_);
      while(_loc2_.compareTo(m) >= 0)
      {
         _loc2_.subTo(m,_loc2_);
      }
   }
}

import flash.net.LocalConnection;
import flash.system.System;

class Memory
{
    
   
   function Memory()
   {
      super();
   }
   
   public static function gc() : void
   {
      try
      {
         new LocalConnection().connect("foo");
         new LocalConnection().connect("foo");
      }
      catch(e:*)
      {
      }
   }
   
   public static function get used() : uint
   {
      return System.totalMemory;
   }
}

import flash.utils.ByteArray;

use namespace bi_internal;

class Hex
{
    
   
   function Hex()
   {
      super();
   }
   
   public static function toArray(param1:String) : ByteArray
   {
      var _loc3_:* = 0;
      param1 = param1.replace(/\s|:/gm,"");
      var _loc2_:ByteArray = new ByteArray();
      if(param1.length & 1)
      {
         param1 = "0" + param1;
      }
      _loc3_ = 0;
      while(_loc3_ < param1.length)
      {
         _loc2_[_loc3_ / 2] = parseInt(param1.substr(_loc3_,2),16);
         _loc3_ += 2;
      }
      return _loc2_;
   }
   
   public static function fromArray(param1:ByteArray, param2:Boolean = false) : String
   {
      var _loc4_:int = 0;
      var _loc3_:String = "";
      _loc4_ = 0;
      while(_loc4_ < param1.length)
      {
         _loc3_ += ("0" + param1[_loc4_].toString(16)).substr(-2,2);
         if(param2)
         {
            if(_loc4_ < param1.length - 1)
            {
               _loc3_ += ":";
            }
         }
         _loc4_++;
      }
      return _loc3_;
   }
   
   public static function toString(param1:String) : String
   {
      var _loc2_:ByteArray = toArray(param1);
      return _loc2_.readUTFBytes(_loc2_.length);
   }
   
   public static function fromString(param1:String, param2:Boolean = false) : String
   {
      var _loc3_:ByteArray = new ByteArray();
      _loc3_.writeUTFBytes(param1);
      return fromArray(_loc3_,param2);
   }
}

import flash.utils.ByteArray;

use namespace bi_internal;

class _SEHWWIWIOED
{
    
   
   function _SEHWWIWIOED()
   {
      super();
   }
   
   public static function readRSAPublicKey(param1:String) : RSAKey
   {
      var _loc3_:* = null;
      var _loc2_:ByteArray = extractBinary("-----BEGIN PUBLIC KEY-----","-----END PUBLIC KEY-----",param1);
      if(_loc2_ == null)
      {
         return null;
      }
      var _loc4_:*;
      if((_loc4_ = DER.parse(_loc2_)) is Array)
      {
         _loc3_ = _loc4_ as Array;
         if(_loc3_[0][0].toString() != "1.2.840.113549.1.1.1")
         {
            return null;
         }
         _loc3_[1].position = 0;
         if((_loc4_ = DER.parse(_loc3_[1])) is Array)
         {
            _loc3_ = _loc4_ as Array;
            return new RSAKey(_loc3_[0],_loc3_[1]);
         }
         return null;
      }
      return null;
   }
   
   private static function extractBinary(param1:String, param2:String, param3:String) : ByteArray
   {
      var _loc5_:int;
      if((_loc5_ = param3.indexOf(param1)) == -1)
      {
         return null;
      }
      _loc5_ += param1.length;
      var _loc6_:int;
      if((_loc6_ = param3.indexOf(param2)) == -1)
      {
         return null;
      }
      var _loc4_:String = (_loc4_ = param3.substring(_loc5_,_loc6_)).replace(/\s/gm,"");
      return Base64encoder.decodeToByteArray(_loc4_);
   }
}

import flash.utils.ByteArray;

use namespace bi_internal;

class Base64encoder
{
   
   private static const BASE64_CHARS:String = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
   
   public static const version:String = "1.0.0";
    
   
   function Base64encoder()
   {
      super();
      throw new Error("Base64 internal class is static container only");
   }
   
   public static function encode(param1:String) : String
   {
      var _loc2_:ByteArray = new ByteArray();
      _loc2_.writeUTFBytes(param1);
      return encodeByteArray(_loc2_);
   }
   
   public static function encodeByteArray(param1:ByteArray) : String
   {
      var _loc4_:* = null;
      var _loc5_:int = 0;
      var _loc6_:* = 0;
      var _loc7_:int = 0;
      var _loc2_:String = "";
      var _loc3_:Array = new Array(4);
      param1.position = 0;
      while(param1.bytesAvailable > 0)
      {
         _loc4_ = [];
         _loc5_ = 0;
         while(_loc5_ < 3 && param1.bytesAvailable > 0)
         {
            _loc4_[_loc5_] = param1.readUnsignedByte();
            _loc5_++;
         }
         _loc3_[0] = (_loc4_[0] & 252) >> 2;
         _loc3_[1] = (_loc4_[0] & 3) << 4 | _loc4_[1] >> 4;
         _loc3_[2] = (_loc4_[1] & 15) << 2 | _loc4_[2] >> 6;
         _loc3_[3] = _loc4_[2] & 63;
         _loc6_ = uint(_loc4_.length);
         while(_loc6_ < 3)
         {
            _loc3_[_loc6_ + 1] = 64;
            _loc6_++;
         }
         _loc7_ = 0;
         while(_loc7_ < _loc3_.length)
         {
            _loc2_ += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(_loc3_[_loc7_]);
            _loc7_++;
         }
      }
      return _loc2_;
   }
   
   public static function decode(param1:String) : String
   {
      var _loc2_:ByteArray = decodeToByteArrayB(param1);
      return _loc2_.readUTFBytes(_loc2_.length);
   }
   
   public static function decodeToByteArray(param1:String) : ByteArray
   {
      var _loc5_:* = 0;
      var _loc6_:int = 0;
      var _loc7_:int = 0;
      var _loc2_:ByteArray = new ByteArray();
      var _loc4_:Array = new Array(4);
      var _loc3_:Array = new Array(3);
      _loc5_ = 0;
      while(_loc5_ < param1.length)
      {
         _loc6_ = 0;
         while(_loc6_ < 4 && _loc5_ + _loc6_ < param1.length)
         {
            _loc4_[_loc6_] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(param1.charAt(_loc5_ + _loc6_));
            _loc6_++;
         }
         _loc3_[0] = (_loc4_[0] << 2) + ((_loc4_[1] & 48) >> 4);
         _loc3_[1] = ((_loc4_[1] & 15) << 4) + ((_loc4_[2] & 60) >> 2);
         _loc3_[2] = ((_loc4_[2] & 3) << 6) + _loc4_[3];
         _loc7_ = 0;
         while(_loc7_ < _loc3_.length)
         {
            if(_loc4_[_loc7_ + 1] == 64)
            {
               break;
            }
            _loc2_.writeByte(_loc3_[_loc7_]);
            _loc7_++;
         }
         _loc5_ += 4;
      }
      _loc2_.position = 0;
      return _loc2_;
   }
   
   public static function decodeToByteArrayB(param1:String) : ByteArray
   {
      var _loc5_:* = 0;
      var _loc6_:int = 0;
      var _loc7_:int = 0;
      var _loc2_:ByteArray = new ByteArray();
      var _loc4_:Array = new Array(4);
      var _loc3_:Array = new Array(3);
      _loc5_ = 0;
      while(_loc5_ < param1.length)
      {
         _loc6_ = 0;
         while(_loc6_ < 4 && _loc5_ + _loc6_ < param1.length)
         {
            _loc4_[_loc6_] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(param1.charAt(_loc5_ + _loc6_));
            while(_loc4_[_loc6_] < 0 && _loc5_ < param1.length)
            {
               _loc5_++;
               _loc4_[_loc6_] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(param1.charAt(_loc5_ + _loc6_));
            }
            _loc6_++;
         }
         _loc3_[0] = (_loc4_[0] << 2) + ((_loc4_[1] & 48) >> 4);
         _loc3_[1] = ((_loc4_[1] & 15) << 4) + ((_loc4_[2] & 60) >> 2);
         _loc3_[2] = ((_loc4_[2] & 3) << 6) + _loc4_[3];
         _loc7_ = 0;
         while(_loc7_ < _loc3_.length)
         {
            if(_loc4_[_loc7_ + 1] == 64)
            {
               break;
            }
            _loc2_.writeByte(_loc3_[_loc7_]);
            _loc7_++;
         }
         _loc5_ += 4;
      }
      _loc2_.position = 0;
      return _loc2_;
   }
}

import flash.utils.ByteArray;

use namespace bi_internal;

class DER
{
   
   public static var indent:String = "";
    
   
   function DER()
   {
      super();
   }
   
   public static function parse(param1:ByteArray, param2:* = null) : IAsn1Type
   {
      var _loc6_:* = 0;
      var _loc3_:* = null;
      var _loc10_:int = 0;
      var _loc9_:* = null;
      var _loc18_:* = null;
      var _loc19_:* = null;
      var _loc15_:* = false;
      var _loc7_:Boolean = false;
      var _loc17_:* = null;
      var _loc20_:* = undefined;
      var _loc14_:int = 0;
      var _loc21_:* = null;
      var _loc16_:* = null;
      var _loc12_:* = null;
      var _loc11_:* = null;
      var _loc4_:* = null;
      var _loc22_:* = null;
      var _loc8_:*;
      var _loc5_:* = ((_loc8_ = int(param1.readUnsignedByte())) & 32) != 0;
      _loc8_ &= 31;
      var _loc13_:*;
      if((_loc13_ = int(param1.readUnsignedByte())) >= 128)
      {
         _loc6_ = _loc13_ & 127;
         _loc13_ = 0;
         while(_loc6_ > 0)
         {
            _loc13_ = _loc13_ << 8 | param1.readUnsignedByte();
            _loc6_--;
         }
      }
      switch(_loc8_)
      {
         case 0:
         case 16:
            _loc10_ = param1.position;
            _loc9_ = new Sequence(_loc8_,_loc13_);
            if((_loc18_ = param2 as Array) != null)
            {
               _loc18_ = _loc18_.concat();
            }
            while(param1.position < _loc10_ + _loc13_)
            {
               _loc19_ = null;
               if(_loc18_ != null)
               {
                  _loc19_ = _loc18_.shift();
               }
               if(_loc19_ != null)
               {
                  while(_loc19_ && _loc19_.optional)
                  {
                     _loc15_ = _loc19_.value is Array;
                     _loc7_ = isConstructedType(param1);
                     if(_loc15_ == _loc7_)
                     {
                        break;
                     }
                     _loc9_.push(_loc19_.defaultValue);
                     _loc9_[_loc19_.name] = _loc19_.defaultValue;
                     _loc19_ = _loc18_.shift();
                  }
               }
               if(_loc19_ != null)
               {
                  _loc17_ = _loc19_.name;
                  _loc20_ = _loc19_.value;
                  if(_loc19_.extract)
                  {
                     _loc14_ = getLengthOfNextElement(param1);
                     (_loc21_ = new ByteArray()).writeBytes(param1,param1.position,_loc14_);
                     _loc9_[_loc17_ + "_bin"] = _loc21_;
                  }
                  _loc16_ = DER.parse(param1,_loc20_);
                  _loc9_.push(_loc16_);
                  _loc9_[_loc17_] = _loc16_;
               }
               else
               {
                  _loc9_.push(DER.parse(param1));
               }
            }
            return _loc9_;
         case 17:
            _loc10_ = param1.position;
            _loc12_ = new Set(_loc8_,_loc13_);
            while(param1.position < _loc10_ + _loc13_)
            {
               _loc12_.push(DER.parse(param1));
            }
            return _loc12_;
         case 2:
            _loc3_ = new ByteArray();
            param1.readBytes(_loc3_,0,_loc13_);
            _loc3_.position = 0;
            return new Integer(_loc8_,_loc13_,_loc3_);
         case 6:
            _loc3_ = new ByteArray();
            param1.readBytes(_loc3_,0,_loc13_);
            _loc3_.position = 0;
            return new ObjectIdentifier(_loc8_,_loc13_,_loc3_);
         default:
            trace("I DONT KNOW HOW TO HANDLE DER stuff of TYPE " + _loc8_);
         case 3:
            if(param1[param1.position] == 0)
            {
               param1.position++;
               _loc13_--;
               break;
            }
            break;
         case 4:
            break;
         case 5:
            return null;
         case 19:
            (_loc4_ = new PrintableString(_loc8_,_loc13_)).setString(param1.readMultiByte(_loc13_,"US-ASCII"));
            return _loc4_;
         case 34:
         case 20:
            (_loc4_ = new PrintableString(_loc8_,_loc13_)).setString(param1.readMultiByte(_loc13_,"latin1"));
            return _loc4_;
         case 23:
            (_loc22_ = new UTCTime(_loc8_,_loc13_)).setUTCTime(param1.readMultiByte(_loc13_,"US-ASCII"));
            return _loc22_;
      }
      _loc11_ = new ByteString(_loc8_,_loc13_);
      param1.readBytes(_loc11_,0,_loc13_);
      return _loc11_;
   }
   
   private static function getLengthOfNextElement(param1:ByteArray) : int
   {
      var _loc4_:* = 0;
      var _loc2_:uint = param1.position;
      param1.position++;
      var _loc3_:* = int(param1.readUnsignedByte());
      if(_loc3_ >= 128)
      {
         _loc4_ = _loc3_ & 127;
         _loc3_ = 0;
         while(_loc4_ > 0)
         {
            _loc3_ = _loc3_ << 8 | param1.readUnsignedByte();
            _loc4_--;
         }
      }
      _loc3_ += param1.position - _loc2_;
      param1.position = _loc2_;
      return _loc3_;
   }
   
   private static function isConstructedType(param1:ByteArray) : Boolean
   {
      var _loc2_:int = param1[param1.position];
      return (_loc2_ & 32) != 0;
   }
   
   public static function wrapDER(param1:int, param2:ByteArray) : ByteArray
   {
      var _loc3_:ByteArray = new ByteArray();
      _loc3_.writeByte(param1);
      var _loc4_:int;
      if((_loc4_ = param2.length) < 128)
      {
         _loc3_.writeByte(_loc4_);
      }
      else if(_loc4_ < 256)
      {
         _loc3_.writeByte(129);
         _loc3_.writeByte(_loc4_);
      }
      else if(_loc4_ < 65536)
      {
         _loc3_.writeByte(130);
         _loc3_.writeByte(_loc4_ >> 8);
         _loc3_.writeByte(_loc4_);
      }
      else if(_loc4_ < 16777216)
      {
         _loc3_.writeByte(131);
         _loc3_.writeByte(_loc4_ >> 16);
         _loc3_.writeByte(_loc4_ >> 8);
         _loc3_.writeByte(_loc4_);
      }
      else
      {
         _loc3_.writeByte(132);
         _loc3_.writeByte(_loc4_ >> 24);
         _loc3_.writeByte(_loc4_ >> 16);
         _loc3_.writeByte(_loc4_ >> 8);
         _loc3_.writeByte(_loc4_);
      }
      _loc3_.writeBytes(param2);
      _loc3_.position = 0;
      return _loc3_;
   }
}

import flash.utils.ByteArray;

class UTCTime implements IAsn1Type
{
    
   
   protected var type:uint;
   
   protected var len:uint;
   
   public var date:Date;
   
   function UTCTime(param1:uint, param2:uint)
   {
      super();
      this.type = param1;
      this.len = param2;
   }
   
   public function getLength() : uint
   {
      return len;
   }
   
   public function getType() : uint
   {
      return type;
   }
   
   public function setUTCTime(param1:String) : void
   {
      var _loc4_:uint;
      if((_loc4_ = parseInt(param1.substr(0,2))) < 50)
      {
         _loc4_ += 2000;
      }
      else
      {
         _loc4_ += 1900;
      }
      var _loc2_:uint = parseInt(param1.substr(2,2));
      var _loc5_:uint = parseInt(param1.substr(4,2));
      var _loc3_:uint = parseInt(param1.substr(6,2));
      var _loc6_:uint = parseInt(param1.substr(8,2));
      date = new Date(_loc4_,_loc2_ - 1,_loc5_,_loc3_,_loc6_);
   }
   
   public function toString() : String
   {
      return "undefinedUTCTime[" + type + "][" + len + "][" + date + "]";
   }
   
   public function toDER() : ByteArray
   {
      return null;
   }
}

import flash.utils.ByteArray;

class PrintableString implements IAsn1Type
{
    
   
   protected var type:uint;
   
   protected var len:uint;
   
   protected var str:String;
   
   function PrintableString(param1:uint, param2:uint)
   {
      super();
      this.type = param1;
      this.len = param2;
   }
   
   public function getLength() : uint
   {
      return len;
   }
   
   public function getType() : uint
   {
      return type;
   }
   
   public function setString(param1:String) : void
   {
      str = param1;
   }
   
   public function getString() : String
   {
      return str;
   }
   
   public function toString() : String
   {
      return DER.indent + str;
   }
   
   public function toDER() : ByteArray
   {
      return null;
   }
}

import flash.utils.ByteArray;

use namespace bi_internal;

dynamic class Sequence extends Array implements IAsn1Type
{
    
   
   protected var type:uint;
   
   protected var len:uint;
   
   function Sequence(param1:uint = 48, param2:uint = 0)
   {
      super();
      this.type = param1;
      this.len = param2;
   }
   
   public function getLength() : uint
   {
      return len;
   }
   
   public function getType() : uint
   {
      return type;
   }
   
   public function toDER() : ByteArray
   {
      var _loc3_:int = 0;
      var _loc1_:* = null;
      var _loc2_:ByteArray = new ByteArray();
      _loc3_ = 0;
      while(_loc3_ < length)
      {
         _loc1_ = this[_loc3_];
         if(_loc1_ == null)
         {
            _loc2_.writeByte(5);
            _loc2_.writeByte(0);
         }
         else
         {
            _loc2_.writeBytes(_loc1_.toDER());
         }
         _loc3_++;
      }
      return DER.wrapDER(type,_loc2_);
   }
   
   public function toString() : String
   {
      var _loc4_:int = 0;
      var _loc2_:Boolean = false;
      var _loc1_:String = "null";
      DER.indent = "undefined    ";
      var _loc3_:String = "";
      _loc4_ = 0;
      while(_loc4_ < length)
      {
         if(this[_loc4_] != null)
         {
            _loc2_ = false;
            for(var _loc5_ in this)
            {
               if(_loc4_.toString() != _loc5_ && this[_loc4_] == this[_loc5_])
               {
                  _loc3_ += _loc5_ + ": " + this[_loc4_] + "\n";
                  _loc2_ = true;
                  break;
               }
            }
            if(!_loc2_)
            {
               _loc3_ += this[_loc4_] + "\n";
            }
         }
         _loc4_++;
      }
      DER.indent = _loc1_;
      return "undefinedSequence[" + type + "][" + len + "][\n" + _loc3_ + "\n" + _loc1_ + "]";
   }
   
   public function findAttributeValue(param1:String) : IAsn1Type
   {
      var _loc5_:* = undefined;
      var _loc3_:* = undefined;
      var _loc4_:* = null;
      for each(var _loc2_ in this)
      {
         if(_loc2_ is Set)
         {
            if((_loc5_ = _loc2_[0]) is Sequence)
            {
               _loc3_ = _loc5_[0];
               if(_loc3_ is ObjectIdentifier)
               {
                  if((_loc4_ = _loc3_ as ObjectIdentifier).toString() == param1)
                  {
                     return _loc5_[1] as IAsn1Type;
                  }
               }
            }
         }
      }
      return null;
   }
}

dynamic class Set extends Sequence implements IAsn1Type
{
    
   
   function Set(param1:uint = 49, param2:uint = 0)
   {
      super(param1,param2);
   }
   
   override public function toString() : String
   {
      var _loc1_:String = "null";
      DER.indent = "undefined    ";
      var _loc2_:String = join("\n");
      DER.indent = _loc1_;
      return "undefinedSet[" + type + "][" + len + "][\n" + _loc2_ + "\n" + _loc1_ + "]";
   }
}

import flash.net.registerClassAlias;
import flash.utils.ByteArray;

use namespace bi_internal;

class ObjectIdentifier implements IAsn1Type
{
   
   {
      registerClassAlias("com.hurlant.util.der.ObjectIdentifier",ObjectIdentifier);
   }
   
   private var type:uint;
   
   private var len:uint;
   
   private var oid:Array;
   
   function ObjectIdentifier(param1:uint = 0, param2:uint = 0, param3:* = null)
   {
      super();
      this.type = param1;
      this.len = param2;
      if(param3 is ByteArray)
      {
         parse(param3 as ByteArray);
      }
      else
      {
         if(!(param3 is String))
         {
            throw new Error("Invalid call to new ObjectIdentifier");
         }
         generate(param3 as String);
      }
   }
   
   private function generate(param1:String) : void
   {
      oid = param1.split(".");
   }
   
   private function parse(param1:ByteArray) : void
   {
      var _loc3_:* = false;
      var _loc5_:uint = param1.readUnsignedByte();
      var _loc2_:* = [];
      _loc2_.push(uint(_loc5_ / 40));
      _loc2_.push(uint(_loc5_ % 40));
      var _loc4_:* = 0;
      while(param1.bytesAvailable > 0)
      {
         _loc3_ = ((_loc5_ = param1.readUnsignedByte()) & 128) == 0;
         _loc5_ &= 127;
         _loc4_ = uint(_loc4_ * 128 + _loc5_);
         if(_loc3_)
         {
            _loc2_.push(_loc4_);
            _loc4_ = 0;
         }
      }
      oid = _loc2_;
   }
   
   public function getLength() : uint
   {
      return len;
   }
   
   public function getType() : uint
   {
      return type;
   }
   
   public function toDER() : ByteArray
   {
      var _loc4_:int = 0;
      var _loc3_:int = 0;
      var _loc2_:* = [];
      _loc2_[0] = NaN;
      _loc4_ = 2;
      while(_loc4_ < oid.length)
      {
         _loc3_ = 0;
         if(_loc3_ < 128)
         {
            _loc2_.push(_loc3_);
         }
         else if(_loc3_ < 16384)
         {
            _loc2_.push(_loc3_ >> 7 | 128);
            _loc2_.push(_loc3_ & 127);
         }
         else if(_loc3_ < 2097152)
         {
            _loc2_.push(_loc3_ >> 14 | 128);
            _loc2_.push(_loc3_ >> 7 & 127 | 128);
            _loc2_.push(_loc3_ & 127);
         }
         else
         {
            if(_loc3_ >= 268435456)
            {
               throw new Error("OID element bigger than we thought. :(");
            }
            _loc2_.push(_loc3_ >> 21 | 128);
            _loc2_.push(_loc3_ >> 14 & 127 | 128);
            _loc2_.push(_loc3_ >> 7 & 127 | 128);
            _loc2_.push(_loc3_ & 127);
         }
         _loc4_++;
      }
      len = _loc2_.length;
      if(type == 0)
      {
         type = 6;
      }
      _loc2_.unshift(len);
      _loc2_.unshift(type);
      var _loc1_:ByteArray = new ByteArray();
      _loc4_ = 0;
      while(_loc4_ < _loc2_.length)
      {
         _loc1_[_loc4_] = _loc2_[_loc4_];
         _loc4_++;
      }
      return _loc1_;
   }
   
   public function toString() : String
   {
      return DER.indent + oid.join(".");
   }
   
   public function dump() : String
   {
      return "OID[" + type + "][" + len + "][" + toString() + "]";
   }
}

import flash.utils.ByteArray;

class Integer extends BigInteger implements IAsn1Type
{
    
   
   private var type:uint;
   
   private var len:uint;
   
   function Integer(param1:uint, param2:uint, param3:ByteArray)
   {
      this.type = param1;
      this.len = param2;
      super(param3);
   }
   
   public function getLength() : uint
   {
      return len;
   }
   
   public function getType() : uint
   {
      return type;
   }
   
   override public function toString(param1:Number = 0) : String
   {
      return "undefinedInteger[" + type + "][" + len + "][" + super.toString(16) + "]";
   }
   
   public function toDER() : ByteArray
   {
      return null;
   }
}

import flash.utils.ByteArray;

class ByteString extends ByteArray implements IAsn1Type
{
    
   
   private var type:uint;
   
   private var len:uint;
   
   function ByteString(param1:uint = 4, param2:uint = 0)
   {
      super();
      this.type = param1;
      this.len = param2;
   }
   
   public function getLength() : uint
   {
      return len;
   }
   
   public function getType() : uint
   {
      return type;
   }
   
   public function toDER() : ByteArray
   {
      return DER.wrapDER(type,this);
   }
   
   override public function toString() : String
   {
      return "undefinedByteString[" + type + "][" + len + "][" + Hex.fromArray(this) + "]";
   }
}

import flash.utils.ByteArray;

interface IPRNG
{
    
   
   function getPoolSize() : uint;
   
   function init(param1:ByteArray) : void;
   
   function next() : uint;
   
   function dispose() : void;
   
   function toString() : String;
}

import flash.utils.ByteArray;

interface IPad
{
    
   
   function pad(param1:ByteArray) : void;
   
   function unpad(param1:ByteArray) : void;
   
   function setBlockSize(param1:uint) : void;
}

import flash.utils.ByteArray;

interface ISymmetricKey
{
    
   
   function getBlockSize() : uint;
   
   function encrypt(param1:ByteArray, param2:uint = 0) : void;
   
   function decrypt(param1:ByteArray, param2:uint = 0) : void;
   
   function dispose() : void;
   
   function toString() : String;
}

import flash.utils.ByteArray;

interface IAsn1Type
{
    
   
   function getType() : uint;
   
   function getLength() : uint;
   
   function toDER() : ByteArray;
}

interface IStreamCipher extends ICipher
{
    
}

interface IMode extends ICipher
{
    
}

import flash.utils.ByteArray;

interface ICipher
{
    
   
   function getBlockSize() : uint;
   
   function encrypt(param1:ByteArray) : void;
   
   function decrypt(param1:ByteArray) : void;
   
   function dispose() : void;
   
   function toString() : String;
}

interface IReduction
{
    
   
   function convert(param1:BigInteger) : BigInteger;
   
   function revert(param1:BigInteger) : BigInteger;
   
   function reduce(param1:BigInteger) : void;
   
   function mulTo(param1:BigInteger, param2:BigInteger, param3:BigInteger) : void;
   
   function sqrTo(param1:BigInteger, param2:BigInteger) : void;
}
